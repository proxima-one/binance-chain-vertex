// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gql

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/proxima-one/binance-chain-subgraph/pkg/models"
	"github.com/vektah/gqlparser"
	"github.com/vektah/gqlparser/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Account struct {
		AccountNumber func(childComplexity int) int
		Address       func(childComplexity int) int
		Balances      func(childComplexity int) int
		PublicKey     func(childComplexity int) int
		Sequence      func(childComplexity int) int
	}

	AtomicSwap struct {
		ClosedTime          func(childComplexity int) int
		CreatedTime         func(childComplexity int) int
		CrossChain          func(childComplexity int) int
		ExpectedIncome      func(childComplexity int) int
		ExpireHeight        func(childComplexity int) int
		FromAddr            func(childComplexity int) int
		InAmount            func(childComplexity int) int
		OutAmount           func(childComplexity int) int
		RandomString        func(childComplexity int) int
		RandomStringHash    func(childComplexity int) int
		RecipientOtherChain func(childComplexity int) int
		Status              func(childComplexity int) int
		SwapID              func(childComplexity int) int
		Timestamp           func(childComplexity int) int
		ToAddr              func(childComplexity int) int
		UpdateTime          func(childComplexity int) int
	}

	Balance struct {
		Free   func(childComplexity int) int
		Frozen func(childComplexity int) int
		Locked func(childComplexity int) int
		Symbol func(childComplexity int) int
	}

	Balances struct {
		Address  func(childComplexity int) int
		Balances func(childComplexity int) int
	}

	BlockStats struct {
		CatchingUp        func(childComplexity int) int
		LatestAppHash     func(childComplexity int) int
		LatestBlockHash   func(childComplexity int) int
		LatestBlockHeight func(childComplexity int) int
		LatestBlockTime   func(childComplexity int) int
	}

	CandleStick struct {
		Close            func(childComplexity int) int
		ClosingTime      func(childComplexity int) int
		High             func(childComplexity int) int
		Low              func(childComplexity int) int
		NumberOfTrades   func(childComplexity int) int
		Open             func(childComplexity int) int
		OpenTime         func(childComplexity int) int
		QuoteAssetVolume func(childComplexity int) int
		Volume           func(childComplexity int) int
	}

	Coin struct {
		Amount func(childComplexity int) int
		Denom  func(childComplexity int) int
	}

	Fee struct {
		Fee               func(childComplexity int) int
		FeeFor            func(childComplexity int) int
		LowerLimitAsMulti func(childComplexity int) int
		MsgType           func(childComplexity int) int
		MultiTransferFee  func(childComplexity int) int
	}

	Market struct {
		BaseAssetSymbol  func(childComplexity int) int
		ListPrice        func(childComplexity int) int
		LotSize          func(childComplexity int) int
		QuoteAssetSymbol func(childComplexity int) int
		TickSize         func(childComplexity int) int
	}

	MarketDepth struct {
		Asks       func(childComplexity int) int
		Bids       func(childComplexity int) int
		SymbolPair func(childComplexity int) int
	}

	MarketTicker struct {
		AskPrice           func(childComplexity int) int
		AskQuantity        func(childComplexity int) int
		BidPrice           func(childComplexity int) int
		CloseTime          func(childComplexity int) int
		Count              func(childComplexity int) int
		FirstID            func(childComplexity int) int
		HighPrice          func(childComplexity int) int
		LastID             func(childComplexity int) int
		LastPrice          func(childComplexity int) int
		LastQuantity       func(childComplexity int) int
		LowPrice           func(childComplexity int) int
		OpenTime           func(childComplexity int) int
		PrevClosePrice     func(childComplexity int) int
		PriceChange        func(childComplexity int) int
		PriceChangePercent func(childComplexity int) int
		QuoteVolume        func(childComplexity int) int
		Symbol             func(childComplexity int) int
		Volume             func(childComplexity int) int
		WeightedAvgPrice   func(childComplexity int) int
	}

	Order struct {
		CumulateQuantity     func(childComplexity int) int
		Fee                  func(childComplexity int) int
		LastExecutedPrice    func(childComplexity int) int
		LastExecutedQuantity func(childComplexity int) int
		OrderCreateTime      func(childComplexity int) int
		OrderID              func(childComplexity int) int
		Owner                func(childComplexity int) int
		Price                func(childComplexity int) int
		Quantity             func(childComplexity int) int
		Side                 func(childComplexity int) int
		Status               func(childComplexity int) int
		Symbol               func(childComplexity int) int
		TimeInForce          func(childComplexity int) int
		TradeID              func(childComplexity int) int
		TransactionHash      func(childComplexity int) int
		TransactionTime      func(childComplexity int) int
		Type                 func(childComplexity int) int
	}

	OrderList struct {
		Orders func(childComplexity int) int
		Total  func(childComplexity int) int
	}

	Proof struct {
		Proof func(childComplexity int) int
		Root  func(childComplexity int) int
	}

	ProximaAccount struct {
		Account func(childComplexity int) int
		Proof   func(childComplexity int) int
	}

	ProximaAtomicSwap struct {
		AtomicSwap func(childComplexity int) int
		Proof      func(childComplexity int) int
	}

	ProximaBlockStats struct {
		BlockStats func(childComplexity int) int
		Proof      func(childComplexity int) int
	}

	ProximaFees struct {
		Fees  func(childComplexity int) int
		Proof func(childComplexity int) int
	}

	ProximaMarketCandleSticks struct {
		Interval           func(childComplexity int) int
		MarketCandlesticks func(childComplexity int) int
		Proof              func(childComplexity int) int
		Symbol             func(childComplexity int) int
	}

	ProximaMarketDepth struct {
		MarketDepth func(childComplexity int) int
		Proof       func(childComplexity int) int
	}

	ProximaMarketTicker struct {
		MarketTicker func(childComplexity int) int
		Proof        func(childComplexity int) int
	}

	ProximaMarketTickers struct {
		MarketTickers func(childComplexity int) int
		Proof         func(childComplexity int) int
	}

	ProximaMarkets struct {
		Markets func(childComplexity int) int
		Proof   func(childComplexity int) int
	}

	ProximaOrder struct {
		Order func(childComplexity int) int
		Proof func(childComplexity int) int
	}

	ProximaTimelocks struct {
		Proof     func(childComplexity int) int
		Timelocks func(childComplexity int) int
	}

	ProximaTokens struct {
		Proof  func(childComplexity int) int
		Tokens func(childComplexity int) int
	}

	ProximaTrade struct {
		Proof func(childComplexity int) int
		Trade func(childComplexity int) int
	}

	ProximaTransaction struct {
		Proof       func(childComplexity int) int
		Transaction func(childComplexity int) int
	}

	ProximaValidators struct {
		Proof      func(childComplexity int) int
		Validators func(childComplexity int) int
	}

	Query struct {
		Account            func(childComplexity int, address *string, prove *bool) int
		AtomicSwap         func(childComplexity int, id *string, prove *bool) int
		AtomicSwaps        func(childComplexity int, fromAddress *string, toAddress *string, startTime *string, endTime *string, limit *int, offset *int, prove *bool) int
		BlockStats         func(childComplexity int, prove *bool) int
		Fees               func(childComplexity int, prove *bool) int
		MarketCandleSticks func(childComplexity int, symbol *string, startTime *string, endTime *string, interval *string, limit *int, prove *bool) int
		MarketDepth        func(childComplexity int, symbolPair *string, limit *int, prove *bool) int
		MarketTicker       func(childComplexity int, symbol *string, prove *bool) int
		MarketTickers      func(childComplexity int, limit *int, offset *int, prove *bool) int
		Markets            func(childComplexity int, limit *int, offset *int, prove *bool) int
		Order              func(childComplexity int, orderID *string, prove *bool) int
		Orders             func(childComplexity int, address *string, symbol *string, start *string, end *string, orderSide *int, open *bool, status *string, total *int, limit *int, offset *int, prove *bool) int
		Timelocks          func(childComplexity int, address *string, id *int, prove *bool) int
		Tokens             func(childComplexity int, limit *int, offset *int, prove *bool) int
		Trade              func(childComplexity int, tradeID *string, prove *bool) int
		Trades             func(childComplexity int, address *string, symbol *string, quoteAssetSymbol *string, blockHeight *string, startTime *string, endTime *string, buyerOrderID *string, sellerOrderID *string, orderSide *int, limit *int, offset *int, prove *bool) int
		Transaction        func(childComplexity int, txHash *string, prove *bool) int
		Transactions       func(childComplexity int, address *string, txType *string, txAsset *string, txSide *int, blockHeight *string, startTime *string, endTime *string, limit *int, offset *int, prove *bool) int
		Validators         func(childComplexity int, prove *bool) int
	}

	Timelock struct {
		Amount      func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Locktime    func(childComplexity int) int
	}

	TimelockList struct {
		Timelocks func(childComplexity int) int
	}

	Token struct {
		Name           func(childComplexity int) int
		OriginalSymbol func(childComplexity int) int
		Owner          func(childComplexity int) int
		Symbol         func(childComplexity int) int
		TotalSupply    func(childComplexity int) int
	}

	Trade struct {
		BaseAsset     func(childComplexity int) int
		BlockHeight   func(childComplexity int) int
		BuyFee        func(childComplexity int) int
		BuySingleFee  func(childComplexity int) int
		BuyerID       func(childComplexity int) int
		BuyerOrderID  func(childComplexity int) int
		Price         func(childComplexity int) int
		Quantity      func(childComplexity int) int
		QuoteAsset    func(childComplexity int) int
		SellFee       func(childComplexity int) int
		SellSingleFee func(childComplexity int) int
		SellerID      func(childComplexity int) int
		SellerOrderID func(childComplexity int) int
		Symbol        func(childComplexity int) int
		TickType      func(childComplexity int) int
		Time          func(childComplexity int) int
		TradeID       func(childComplexity int) int
	}

	Transaction struct {
		BlockHeight func(childComplexity int) int
		Code        func(childComplexity int) int
		Data        func(childComplexity int) int
		FromAddr    func(childComplexity int) int
		Memo        func(childComplexity int) int
		OrderID     func(childComplexity int) int
		ProposalID  func(childComplexity int) int
		Sequence    func(childComplexity int) int
		Source      func(childComplexity int) int
		SwapID      func(childComplexity int) int
		TimeStamp   func(childComplexity int) int
		ToAddr      func(childComplexity int) int
		TxAsset     func(childComplexity int) int
		TxFee       func(childComplexity int) int
		TxHash      func(childComplexity int) int
		TxType      func(childComplexity int) int
		Value       func(childComplexity int) int
	}

	Validator struct {
		Accum       func(childComplexity int) int
		Address     func(childComplexity int) int
		PubKey      func(childComplexity int) int
		VotingPower func(childComplexity int) int
	}
}

type QueryResolver interface {
	BlockStats(ctx context.Context, prove *bool) (*models.ProximaBlockStats, error)
	Fees(ctx context.Context, prove *bool) (*models.ProximaFees, error)
	Tokens(ctx context.Context, limit *int, offset *int, prove *bool) (*models.ProximaTokens, error)
	Account(ctx context.Context, address *string, prove *bool) (*models.ProximaAccount, error)
	Orders(ctx context.Context, address *string, symbol *string, start *string, end *string, orderSide *int, open *bool, status *string, total *int, limit *int, offset *int, prove *bool) ([]*models.ProximaOrder, error)
	Order(ctx context.Context, orderID *string, prove *bool) (*models.ProximaOrder, error)
	Transactions(ctx context.Context, address *string, txType *string, txAsset *string, txSide *int, blockHeight *string, startTime *string, endTime *string, limit *int, offset *int, prove *bool) ([]*models.ProximaTransaction, error)
	Transaction(ctx context.Context, txHash *string, prove *bool) (*models.ProximaTransaction, error)
	Markets(ctx context.Context, limit *int, offset *int, prove *bool) (*models.ProximaMarkets, error)
	MarketTicker(ctx context.Context, symbol *string, prove *bool) (*models.ProximaMarketTicker, error)
	MarketTickers(ctx context.Context, limit *int, offset *int, prove *bool) (*models.ProximaMarketTickers, error)
	MarketDepth(ctx context.Context, symbolPair *string, limit *int, prove *bool) (*models.ProximaMarketDepth, error)
	MarketCandleSticks(ctx context.Context, symbol *string, startTime *string, endTime *string, interval *string, limit *int, prove *bool) (*models.ProximaMarketCandleSticks, error)
	Trades(ctx context.Context, address *string, symbol *string, quoteAssetSymbol *string, blockHeight *string, startTime *string, endTime *string, buyerOrderID *string, sellerOrderID *string, orderSide *int, limit *int, offset *int, prove *bool) ([]*models.ProximaTrade, error)
	Trade(ctx context.Context, tradeID *string, prove *bool) (*models.ProximaTrade, error)
	AtomicSwaps(ctx context.Context, fromAddress *string, toAddress *string, startTime *string, endTime *string, limit *int, offset *int, prove *bool) ([]*models.ProximaAtomicSwap, error)
	AtomicSwap(ctx context.Context, id *string, prove *bool) (*models.ProximaAtomicSwap, error)
	Validators(ctx context.Context, prove *bool) (*models.ProximaValidators, error)
	Timelocks(ctx context.Context, address *string, id *int, prove *bool) (*models.ProximaTimelocks, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Account.account_number":
		if e.complexity.Account.AccountNumber == nil {
			break
		}

		return e.complexity.Account.AccountNumber(childComplexity), true

	case "Account.address":
		if e.complexity.Account.Address == nil {
			break
		}

		return e.complexity.Account.Address(childComplexity), true

	case "Account.balances":
		if e.complexity.Account.Balances == nil {
			break
		}

		return e.complexity.Account.Balances(childComplexity), true

	case "Account.public_key":
		if e.complexity.Account.PublicKey == nil {
			break
		}

		return e.complexity.Account.PublicKey(childComplexity), true

	case "Account.sequence":
		if e.complexity.Account.Sequence == nil {
			break
		}

		return e.complexity.Account.Sequence(childComplexity), true

	case "AtomicSwap.closedTime":
		if e.complexity.AtomicSwap.ClosedTime == nil {
			break
		}

		return e.complexity.AtomicSwap.ClosedTime(childComplexity), true

	case "AtomicSwap.createdTime":
		if e.complexity.AtomicSwap.CreatedTime == nil {
			break
		}

		return e.complexity.AtomicSwap.CreatedTime(childComplexity), true

	case "AtomicSwap.crossChain":
		if e.complexity.AtomicSwap.CrossChain == nil {
			break
		}

		return e.complexity.AtomicSwap.CrossChain(childComplexity), true

	case "AtomicSwap.expectedIncome":
		if e.complexity.AtomicSwap.ExpectedIncome == nil {
			break
		}

		return e.complexity.AtomicSwap.ExpectedIncome(childComplexity), true

	case "AtomicSwap.expireHeight":
		if e.complexity.AtomicSwap.ExpireHeight == nil {
			break
		}

		return e.complexity.AtomicSwap.ExpireHeight(childComplexity), true

	case "AtomicSwap.fromAddr":
		if e.complexity.AtomicSwap.FromAddr == nil {
			break
		}

		return e.complexity.AtomicSwap.FromAddr(childComplexity), true

	case "AtomicSwap.inAmount":
		if e.complexity.AtomicSwap.InAmount == nil {
			break
		}

		return e.complexity.AtomicSwap.InAmount(childComplexity), true

	case "AtomicSwap.outAmount":
		if e.complexity.AtomicSwap.OutAmount == nil {
			break
		}

		return e.complexity.AtomicSwap.OutAmount(childComplexity), true

	case "AtomicSwap.randomString":
		if e.complexity.AtomicSwap.RandomString == nil {
			break
		}

		return e.complexity.AtomicSwap.RandomString(childComplexity), true

	case "AtomicSwap.randomStringHash":
		if e.complexity.AtomicSwap.RandomStringHash == nil {
			break
		}

		return e.complexity.AtomicSwap.RandomStringHash(childComplexity), true

	case "AtomicSwap.recipientOtherChain":
		if e.complexity.AtomicSwap.RecipientOtherChain == nil {
			break
		}

		return e.complexity.AtomicSwap.RecipientOtherChain(childComplexity), true

	case "AtomicSwap.status":
		if e.complexity.AtomicSwap.Status == nil {
			break
		}

		return e.complexity.AtomicSwap.Status(childComplexity), true

	case "AtomicSwap.swapId":
		if e.complexity.AtomicSwap.SwapID == nil {
			break
		}

		return e.complexity.AtomicSwap.SwapID(childComplexity), true

	case "AtomicSwap.timestamp":
		if e.complexity.AtomicSwap.Timestamp == nil {
			break
		}

		return e.complexity.AtomicSwap.Timestamp(childComplexity), true

	case "AtomicSwap.toAddr":
		if e.complexity.AtomicSwap.ToAddr == nil {
			break
		}

		return e.complexity.AtomicSwap.ToAddr(childComplexity), true

	case "AtomicSwap.updateTime":
		if e.complexity.AtomicSwap.UpdateTime == nil {
			break
		}

		return e.complexity.AtomicSwap.UpdateTime(childComplexity), true

	case "Balance.free":
		if e.complexity.Balance.Free == nil {
			break
		}

		return e.complexity.Balance.Free(childComplexity), true

	case "Balance.frozen":
		if e.complexity.Balance.Frozen == nil {
			break
		}

		return e.complexity.Balance.Frozen(childComplexity), true

	case "Balance.locked":
		if e.complexity.Balance.Locked == nil {
			break
		}

		return e.complexity.Balance.Locked(childComplexity), true

	case "Balance.symbol":
		if e.complexity.Balance.Symbol == nil {
			break
		}

		return e.complexity.Balance.Symbol(childComplexity), true

	case "Balances.address":
		if e.complexity.Balances.Address == nil {
			break
		}

		return e.complexity.Balances.Address(childComplexity), true

	case "Balances.balances":
		if e.complexity.Balances.Balances == nil {
			break
		}

		return e.complexity.Balances.Balances(childComplexity), true

	case "BlockStats.catching_up":
		if e.complexity.BlockStats.CatchingUp == nil {
			break
		}

		return e.complexity.BlockStats.CatchingUp(childComplexity), true

	case "BlockStats.latest_app_hash":
		if e.complexity.BlockStats.LatestAppHash == nil {
			break
		}

		return e.complexity.BlockStats.LatestAppHash(childComplexity), true

	case "BlockStats.latest_block_hash":
		if e.complexity.BlockStats.LatestBlockHash == nil {
			break
		}

		return e.complexity.BlockStats.LatestBlockHash(childComplexity), true

	case "BlockStats.latest_block_height":
		if e.complexity.BlockStats.LatestBlockHeight == nil {
			break
		}

		return e.complexity.BlockStats.LatestBlockHeight(childComplexity), true

	case "BlockStats.latest_block_time":
		if e.complexity.BlockStats.LatestBlockTime == nil {
			break
		}

		return e.complexity.BlockStats.LatestBlockTime(childComplexity), true

	case "CandleStick.close":
		if e.complexity.CandleStick.Close == nil {
			break
		}

		return e.complexity.CandleStick.Close(childComplexity), true

	case "CandleStick.closingTime":
		if e.complexity.CandleStick.ClosingTime == nil {
			break
		}

		return e.complexity.CandleStick.ClosingTime(childComplexity), true

	case "CandleStick.high":
		if e.complexity.CandleStick.High == nil {
			break
		}

		return e.complexity.CandleStick.High(childComplexity), true

	case "CandleStick.low":
		if e.complexity.CandleStick.Low == nil {
			break
		}

		return e.complexity.CandleStick.Low(childComplexity), true

	case "CandleStick.numberOfTrades":
		if e.complexity.CandleStick.NumberOfTrades == nil {
			break
		}

		return e.complexity.CandleStick.NumberOfTrades(childComplexity), true

	case "CandleStick.open":
		if e.complexity.CandleStick.Open == nil {
			break
		}

		return e.complexity.CandleStick.Open(childComplexity), true

	case "CandleStick.openTime":
		if e.complexity.CandleStick.OpenTime == nil {
			break
		}

		return e.complexity.CandleStick.OpenTime(childComplexity), true

	case "CandleStick.quoteAssetVolume":
		if e.complexity.CandleStick.QuoteAssetVolume == nil {
			break
		}

		return e.complexity.CandleStick.QuoteAssetVolume(childComplexity), true

	case "CandleStick.volume":
		if e.complexity.CandleStick.Volume == nil {
			break
		}

		return e.complexity.CandleStick.Volume(childComplexity), true

	case "Coin.amount":
		if e.complexity.Coin.Amount == nil {
			break
		}

		return e.complexity.Coin.Amount(childComplexity), true

	case "Coin.denom":
		if e.complexity.Coin.Denom == nil {
			break
		}

		return e.complexity.Coin.Denom(childComplexity), true

	case "Fee.fee":
		if e.complexity.Fee.Fee == nil {
			break
		}

		return e.complexity.Fee.Fee(childComplexity), true

	case "Fee.fee_for":
		if e.complexity.Fee.FeeFor == nil {
			break
		}

		return e.complexity.Fee.FeeFor(childComplexity), true

	case "Fee.lower_limit_as_multi":
		if e.complexity.Fee.LowerLimitAsMulti == nil {
			break
		}

		return e.complexity.Fee.LowerLimitAsMulti(childComplexity), true

	case "Fee.msg_type":
		if e.complexity.Fee.MsgType == nil {
			break
		}

		return e.complexity.Fee.MsgType(childComplexity), true

	case "Fee.multi_transfer_fee":
		if e.complexity.Fee.MultiTransferFee == nil {
			break
		}

		return e.complexity.Fee.MultiTransferFee(childComplexity), true

	case "Market.base_asset_symbol":
		if e.complexity.Market.BaseAssetSymbol == nil {
			break
		}

		return e.complexity.Market.BaseAssetSymbol(childComplexity), true

	case "Market.list_price":
		if e.complexity.Market.ListPrice == nil {
			break
		}

		return e.complexity.Market.ListPrice(childComplexity), true

	case "Market.lot_size":
		if e.complexity.Market.LotSize == nil {
			break
		}

		return e.complexity.Market.LotSize(childComplexity), true

	case "Market.quote_asset_symbol":
		if e.complexity.Market.QuoteAssetSymbol == nil {
			break
		}

		return e.complexity.Market.QuoteAssetSymbol(childComplexity), true

	case "Market.tick_size":
		if e.complexity.Market.TickSize == nil {
			break
		}

		return e.complexity.Market.TickSize(childComplexity), true

	case "MarketDepth.asks":
		if e.complexity.MarketDepth.Asks == nil {
			break
		}

		return e.complexity.MarketDepth.Asks(childComplexity), true

	case "MarketDepth.bids":
		if e.complexity.MarketDepth.Bids == nil {
			break
		}

		return e.complexity.MarketDepth.Bids(childComplexity), true

	case "MarketDepth.symbol_pair":
		if e.complexity.MarketDepth.SymbolPair == nil {
			break
		}

		return e.complexity.MarketDepth.SymbolPair(childComplexity), true

	case "MarketTicker.askPrice":
		if e.complexity.MarketTicker.AskPrice == nil {
			break
		}

		return e.complexity.MarketTicker.AskPrice(childComplexity), true

	case "MarketTicker.askQuantity":
		if e.complexity.MarketTicker.AskQuantity == nil {
			break
		}

		return e.complexity.MarketTicker.AskQuantity(childComplexity), true

	case "MarketTicker.bidPrice":
		if e.complexity.MarketTicker.BidPrice == nil {
			break
		}

		return e.complexity.MarketTicker.BidPrice(childComplexity), true

	case "MarketTicker.closeTime":
		if e.complexity.MarketTicker.CloseTime == nil {
			break
		}

		return e.complexity.MarketTicker.CloseTime(childComplexity), true

	case "MarketTicker.count":
		if e.complexity.MarketTicker.Count == nil {
			break
		}

		return e.complexity.MarketTicker.Count(childComplexity), true

	case "MarketTicker.firstId":
		if e.complexity.MarketTicker.FirstID == nil {
			break
		}

		return e.complexity.MarketTicker.FirstID(childComplexity), true

	case "MarketTicker.highPrice":
		if e.complexity.MarketTicker.HighPrice == nil {
			break
		}

		return e.complexity.MarketTicker.HighPrice(childComplexity), true

	case "MarketTicker.lastId":
		if e.complexity.MarketTicker.LastID == nil {
			break
		}

		return e.complexity.MarketTicker.LastID(childComplexity), true

	case "MarketTicker.lastPrice":
		if e.complexity.MarketTicker.LastPrice == nil {
			break
		}

		return e.complexity.MarketTicker.LastPrice(childComplexity), true

	case "MarketTicker.lastQuantity":
		if e.complexity.MarketTicker.LastQuantity == nil {
			break
		}

		return e.complexity.MarketTicker.LastQuantity(childComplexity), true

	case "MarketTicker.lowPrice":
		if e.complexity.MarketTicker.LowPrice == nil {
			break
		}

		return e.complexity.MarketTicker.LowPrice(childComplexity), true

	case "MarketTicker.openTime":
		if e.complexity.MarketTicker.OpenTime == nil {
			break
		}

		return e.complexity.MarketTicker.OpenTime(childComplexity), true

	case "MarketTicker.prevClosePrice":
		if e.complexity.MarketTicker.PrevClosePrice == nil {
			break
		}

		return e.complexity.MarketTicker.PrevClosePrice(childComplexity), true

	case "MarketTicker.priceChange":
		if e.complexity.MarketTicker.PriceChange == nil {
			break
		}

		return e.complexity.MarketTicker.PriceChange(childComplexity), true

	case "MarketTicker.priceChangePercent":
		if e.complexity.MarketTicker.PriceChangePercent == nil {
			break
		}

		return e.complexity.MarketTicker.PriceChangePercent(childComplexity), true

	case "MarketTicker.quoteVolume":
		if e.complexity.MarketTicker.QuoteVolume == nil {
			break
		}

		return e.complexity.MarketTicker.QuoteVolume(childComplexity), true

	case "MarketTicker.symbol":
		if e.complexity.MarketTicker.Symbol == nil {
			break
		}

		return e.complexity.MarketTicker.Symbol(childComplexity), true

	case "MarketTicker.volume":
		if e.complexity.MarketTicker.Volume == nil {
			break
		}

		return e.complexity.MarketTicker.Volume(childComplexity), true

	case "MarketTicker.weightedAvgPrice":
		if e.complexity.MarketTicker.WeightedAvgPrice == nil {
			break
		}

		return e.complexity.MarketTicker.WeightedAvgPrice(childComplexity), true

	case "Order.cumulateQuantity":
		if e.complexity.Order.CumulateQuantity == nil {
			break
		}

		return e.complexity.Order.CumulateQuantity(childComplexity), true

	case "Order.fee":
		if e.complexity.Order.Fee == nil {
			break
		}

		return e.complexity.Order.Fee(childComplexity), true

	case "Order.lastExecutedPrice":
		if e.complexity.Order.LastExecutedPrice == nil {
			break
		}

		return e.complexity.Order.LastExecutedPrice(childComplexity), true

	case "Order.lastExecutedQuantity":
		if e.complexity.Order.LastExecutedQuantity == nil {
			break
		}

		return e.complexity.Order.LastExecutedQuantity(childComplexity), true

	case "Order.orderCreateTime":
		if e.complexity.Order.OrderCreateTime == nil {
			break
		}

		return e.complexity.Order.OrderCreateTime(childComplexity), true

	case "Order.orderId":
		if e.complexity.Order.OrderID == nil {
			break
		}

		return e.complexity.Order.OrderID(childComplexity), true

	case "Order.owner":
		if e.complexity.Order.Owner == nil {
			break
		}

		return e.complexity.Order.Owner(childComplexity), true

	case "Order.price":
		if e.complexity.Order.Price == nil {
			break
		}

		return e.complexity.Order.Price(childComplexity), true

	case "Order.quantity":
		if e.complexity.Order.Quantity == nil {
			break
		}

		return e.complexity.Order.Quantity(childComplexity), true

	case "Order.side":
		if e.complexity.Order.Side == nil {
			break
		}

		return e.complexity.Order.Side(childComplexity), true

	case "Order.status":
		if e.complexity.Order.Status == nil {
			break
		}

		return e.complexity.Order.Status(childComplexity), true

	case "Order.symbol":
		if e.complexity.Order.Symbol == nil {
			break
		}

		return e.complexity.Order.Symbol(childComplexity), true

	case "Order.timeInForce":
		if e.complexity.Order.TimeInForce == nil {
			break
		}

		return e.complexity.Order.TimeInForce(childComplexity), true

	case "Order.tradeId":
		if e.complexity.Order.TradeID == nil {
			break
		}

		return e.complexity.Order.TradeID(childComplexity), true

	case "Order.transactionHash":
		if e.complexity.Order.TransactionHash == nil {
			break
		}

		return e.complexity.Order.TransactionHash(childComplexity), true

	case "Order.transactionTime":
		if e.complexity.Order.TransactionTime == nil {
			break
		}

		return e.complexity.Order.TransactionTime(childComplexity), true

	case "Order.type":
		if e.complexity.Order.Type == nil {
			break
		}

		return e.complexity.Order.Type(childComplexity), true

	case "OrderList.orders":
		if e.complexity.OrderList.Orders == nil {
			break
		}

		return e.complexity.OrderList.Orders(childComplexity), true

	case "OrderList.total":
		if e.complexity.OrderList.Total == nil {
			break
		}

		return e.complexity.OrderList.Total(childComplexity), true

	case "Proof.proof":
		if e.complexity.Proof.Proof == nil {
			break
		}

		return e.complexity.Proof.Proof(childComplexity), true

	case "Proof.root":
		if e.complexity.Proof.Root == nil {
			break
		}

		return e.complexity.Proof.Root(childComplexity), true

	case "ProximaAccount.account":
		if e.complexity.ProximaAccount.Account == nil {
			break
		}

		return e.complexity.ProximaAccount.Account(childComplexity), true

	case "ProximaAccount.proof":
		if e.complexity.ProximaAccount.Proof == nil {
			break
		}

		return e.complexity.ProximaAccount.Proof(childComplexity), true

	case "ProximaAtomicSwap.atomic_swap":
		if e.complexity.ProximaAtomicSwap.AtomicSwap == nil {
			break
		}

		return e.complexity.ProximaAtomicSwap.AtomicSwap(childComplexity), true

	case "ProximaAtomicSwap.proof":
		if e.complexity.ProximaAtomicSwap.Proof == nil {
			break
		}

		return e.complexity.ProximaAtomicSwap.Proof(childComplexity), true

	case "ProximaBlockStats.block_stats":
		if e.complexity.ProximaBlockStats.BlockStats == nil {
			break
		}

		return e.complexity.ProximaBlockStats.BlockStats(childComplexity), true

	case "ProximaBlockStats.proof":
		if e.complexity.ProximaBlockStats.Proof == nil {
			break
		}

		return e.complexity.ProximaBlockStats.Proof(childComplexity), true

	case "ProximaFees.fees":
		if e.complexity.ProximaFees.Fees == nil {
			break
		}

		return e.complexity.ProximaFees.Fees(childComplexity), true

	case "ProximaFees.proof":
		if e.complexity.ProximaFees.Proof == nil {
			break
		}

		return e.complexity.ProximaFees.Proof(childComplexity), true

	case "ProximaMarketCandleSticks.interval":
		if e.complexity.ProximaMarketCandleSticks.Interval == nil {
			break
		}

		return e.complexity.ProximaMarketCandleSticks.Interval(childComplexity), true

	case "ProximaMarketCandleSticks.market_candlesticks":
		if e.complexity.ProximaMarketCandleSticks.MarketCandlesticks == nil {
			break
		}

		return e.complexity.ProximaMarketCandleSticks.MarketCandlesticks(childComplexity), true

	case "ProximaMarketCandleSticks.proof":
		if e.complexity.ProximaMarketCandleSticks.Proof == nil {
			break
		}

		return e.complexity.ProximaMarketCandleSticks.Proof(childComplexity), true

	case "ProximaMarketCandleSticks.symbol":
		if e.complexity.ProximaMarketCandleSticks.Symbol == nil {
			break
		}

		return e.complexity.ProximaMarketCandleSticks.Symbol(childComplexity), true

	case "ProximaMarketDepth.market_depth":
		if e.complexity.ProximaMarketDepth.MarketDepth == nil {
			break
		}

		return e.complexity.ProximaMarketDepth.MarketDepth(childComplexity), true

	case "ProximaMarketDepth.proof":
		if e.complexity.ProximaMarketDepth.Proof == nil {
			break
		}

		return e.complexity.ProximaMarketDepth.Proof(childComplexity), true

	case "ProximaMarketTicker.market_ticker":
		if e.complexity.ProximaMarketTicker.MarketTicker == nil {
			break
		}

		return e.complexity.ProximaMarketTicker.MarketTicker(childComplexity), true

	case "ProximaMarketTicker.proof":
		if e.complexity.ProximaMarketTicker.Proof == nil {
			break
		}

		return e.complexity.ProximaMarketTicker.Proof(childComplexity), true

	case "ProximaMarketTickers.market_tickers":
		if e.complexity.ProximaMarketTickers.MarketTickers == nil {
			break
		}

		return e.complexity.ProximaMarketTickers.MarketTickers(childComplexity), true

	case "ProximaMarketTickers.proof":
		if e.complexity.ProximaMarketTickers.Proof == nil {
			break
		}

		return e.complexity.ProximaMarketTickers.Proof(childComplexity), true

	case "ProximaMarkets.markets":
		if e.complexity.ProximaMarkets.Markets == nil {
			break
		}

		return e.complexity.ProximaMarkets.Markets(childComplexity), true

	case "ProximaMarkets.proof":
		if e.complexity.ProximaMarkets.Proof == nil {
			break
		}

		return e.complexity.ProximaMarkets.Proof(childComplexity), true

	case "ProximaOrder.order":
		if e.complexity.ProximaOrder.Order == nil {
			break
		}

		return e.complexity.ProximaOrder.Order(childComplexity), true

	case "ProximaOrder.proof":
		if e.complexity.ProximaOrder.Proof == nil {
			break
		}

		return e.complexity.ProximaOrder.Proof(childComplexity), true

	case "ProximaTimelocks.proof":
		if e.complexity.ProximaTimelocks.Proof == nil {
			break
		}

		return e.complexity.ProximaTimelocks.Proof(childComplexity), true

	case "ProximaTimelocks.timelocks":
		if e.complexity.ProximaTimelocks.Timelocks == nil {
			break
		}

		return e.complexity.ProximaTimelocks.Timelocks(childComplexity), true

	case "ProximaTokens.proof":
		if e.complexity.ProximaTokens.Proof == nil {
			break
		}

		return e.complexity.ProximaTokens.Proof(childComplexity), true

	case "ProximaTokens.tokens":
		if e.complexity.ProximaTokens.Tokens == nil {
			break
		}

		return e.complexity.ProximaTokens.Tokens(childComplexity), true

	case "ProximaTrade.proof":
		if e.complexity.ProximaTrade.Proof == nil {
			break
		}

		return e.complexity.ProximaTrade.Proof(childComplexity), true

	case "ProximaTrade.trade":
		if e.complexity.ProximaTrade.Trade == nil {
			break
		}

		return e.complexity.ProximaTrade.Trade(childComplexity), true

	case "ProximaTransaction.proof":
		if e.complexity.ProximaTransaction.Proof == nil {
			break
		}

		return e.complexity.ProximaTransaction.Proof(childComplexity), true

	case "ProximaTransaction.transaction":
		if e.complexity.ProximaTransaction.Transaction == nil {
			break
		}

		return e.complexity.ProximaTransaction.Transaction(childComplexity), true

	case "ProximaValidators.proof":
		if e.complexity.ProximaValidators.Proof == nil {
			break
		}

		return e.complexity.ProximaValidators.Proof(childComplexity), true

	case "ProximaValidators.validators":
		if e.complexity.ProximaValidators.Validators == nil {
			break
		}

		return e.complexity.ProximaValidators.Validators(childComplexity), true

	case "Query.account":
		if e.complexity.Query.Account == nil {
			break
		}

		args, err := ec.field_Query_account_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Account(childComplexity, args["address"].(*string), args["prove"].(*bool)), true

	case "Query.atomicSwap":
		if e.complexity.Query.AtomicSwap == nil {
			break
		}

		args, err := ec.field_Query_atomicSwap_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AtomicSwap(childComplexity, args["id"].(*string), args["prove"].(*bool)), true

	case "Query.atomicSwaps":
		if e.complexity.Query.AtomicSwaps == nil {
			break
		}

		args, err := ec.field_Query_atomicSwaps_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AtomicSwaps(childComplexity, args["fromAddress"].(*string), args["toAddress"].(*string), args["startTime"].(*string), args["endTime"].(*string), args["limit"].(*int), args["offset"].(*int), args["prove"].(*bool)), true

	case "Query.blockStats":
		if e.complexity.Query.BlockStats == nil {
			break
		}

		args, err := ec.field_Query_blockStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BlockStats(childComplexity, args["prove"].(*bool)), true

	case "Query.fees":
		if e.complexity.Query.Fees == nil {
			break
		}

		args, err := ec.field_Query_fees_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Fees(childComplexity, args["prove"].(*bool)), true

	case "Query.marketCandleSticks":
		if e.complexity.Query.MarketCandleSticks == nil {
			break
		}

		args, err := ec.field_Query_marketCandleSticks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MarketCandleSticks(childComplexity, args["symbol"].(*string), args["startTime"].(*string), args["endTime"].(*string), args["interval"].(*string), args["limit"].(*int), args["prove"].(*bool)), true

	case "Query.marketDepth":
		if e.complexity.Query.MarketDepth == nil {
			break
		}

		args, err := ec.field_Query_marketDepth_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MarketDepth(childComplexity, args["symbol_pair"].(*string), args["limit"].(*int), args["prove"].(*bool)), true

	case "Query.marketTicker":
		if e.complexity.Query.MarketTicker == nil {
			break
		}

		args, err := ec.field_Query_marketTicker_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MarketTicker(childComplexity, args["symbol"].(*string), args["prove"].(*bool)), true

	case "Query.marketTickers":
		if e.complexity.Query.MarketTickers == nil {
			break
		}

		args, err := ec.field_Query_marketTickers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MarketTickers(childComplexity, args["limit"].(*int), args["offset"].(*int), args["prove"].(*bool)), true

	case "Query.markets":
		if e.complexity.Query.Markets == nil {
			break
		}

		args, err := ec.field_Query_markets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Markets(childComplexity, args["limit"].(*int), args["offset"].(*int), args["prove"].(*bool)), true

	case "Query.order":
		if e.complexity.Query.Order == nil {
			break
		}

		args, err := ec.field_Query_order_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Order(childComplexity, args["orderId"].(*string), args["prove"].(*bool)), true

	case "Query.orders":
		if e.complexity.Query.Orders == nil {
			break
		}

		args, err := ec.field_Query_orders_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Orders(childComplexity, args["address"].(*string), args["symbol"].(*string), args["start"].(*string), args["end"].(*string), args["orderSide"].(*int), args["open"].(*bool), args["status"].(*string), args["total"].(*int), args["limit"].(*int), args["offset"].(*int), args["prove"].(*bool)), true

	case "Query.timelocks":
		if e.complexity.Query.Timelocks == nil {
			break
		}

		args, err := ec.field_Query_timelocks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Timelocks(childComplexity, args["address"].(*string), args["id"].(*int), args["prove"].(*bool)), true

	case "Query.tokens":
		if e.complexity.Query.Tokens == nil {
			break
		}

		args, err := ec.field_Query_tokens_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tokens(childComplexity, args["limit"].(*int), args["offset"].(*int), args["prove"].(*bool)), true

	case "Query.trade":
		if e.complexity.Query.Trade == nil {
			break
		}

		args, err := ec.field_Query_trade_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Trade(childComplexity, args["tradeId"].(*string), args["prove"].(*bool)), true

	case "Query.trades":
		if e.complexity.Query.Trades == nil {
			break
		}

		args, err := ec.field_Query_trades_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Trades(childComplexity, args["address"].(*string), args["symbol"].(*string), args["quoteAssetSymbol"].(*string), args["blockHeight"].(*string), args["startTime"].(*string), args["endTime"].(*string), args["buyerOrderId"].(*string), args["sellerOrderId"].(*string), args["orderSide"].(*int), args["limit"].(*int), args["offset"].(*int), args["prove"].(*bool)), true

	case "Query.transaction":
		if e.complexity.Query.Transaction == nil {
			break
		}

		args, err := ec.field_Query_transaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Transaction(childComplexity, args["txHash"].(*string), args["prove"].(*bool)), true

	case "Query.transactions":
		if e.complexity.Query.Transactions == nil {
			break
		}

		args, err := ec.field_Query_transactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Transactions(childComplexity, args["address"].(*string), args["txType"].(*string), args["txAsset"].(*string), args["txSide"].(*int), args["blockHeight"].(*string), args["startTime"].(*string), args["endTime"].(*string), args["limit"].(*int), args["offset"].(*int), args["prove"].(*bool)), true

	case "Query.validators":
		if e.complexity.Query.Validators == nil {
			break
		}

		args, err := ec.field_Query_validators_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Validators(childComplexity, args["prove"].(*bool)), true

	case "Timelock.amount":
		if e.complexity.Timelock.Amount == nil {
			break
		}

		return e.complexity.Timelock.Amount(childComplexity), true

	case "Timelock.description":
		if e.complexity.Timelock.Description == nil {
			break
		}

		return e.complexity.Timelock.Description(childComplexity), true

	case "Timelock.ID":
		if e.complexity.Timelock.ID == nil {
			break
		}

		return e.complexity.Timelock.ID(childComplexity), true

	case "Timelock.locktime":
		if e.complexity.Timelock.Locktime == nil {
			break
		}

		return e.complexity.Timelock.Locktime(childComplexity), true

	case "TimelockList.timelocks":
		if e.complexity.TimelockList.Timelocks == nil {
			break
		}

		return e.complexity.TimelockList.Timelocks(childComplexity), true

	case "Token.name":
		if e.complexity.Token.Name == nil {
			break
		}

		return e.complexity.Token.Name(childComplexity), true

	case "Token.original_symbol":
		if e.complexity.Token.OriginalSymbol == nil {
			break
		}

		return e.complexity.Token.OriginalSymbol(childComplexity), true

	case "Token.owner":
		if e.complexity.Token.Owner == nil {
			break
		}

		return e.complexity.Token.Owner(childComplexity), true

	case "Token.symbol":
		if e.complexity.Token.Symbol == nil {
			break
		}

		return e.complexity.Token.Symbol(childComplexity), true

	case "Token.total_supply":
		if e.complexity.Token.TotalSupply == nil {
			break
		}

		return e.complexity.Token.TotalSupply(childComplexity), true

	case "Trade.baseAsset":
		if e.complexity.Trade.BaseAsset == nil {
			break
		}

		return e.complexity.Trade.BaseAsset(childComplexity), true

	case "Trade.blockHeight":
		if e.complexity.Trade.BlockHeight == nil {
			break
		}

		return e.complexity.Trade.BlockHeight(childComplexity), true

	case "Trade.buyFee":
		if e.complexity.Trade.BuyFee == nil {
			break
		}

		return e.complexity.Trade.BuyFee(childComplexity), true

	case "Trade.buySingleFee":
		if e.complexity.Trade.BuySingleFee == nil {
			break
		}

		return e.complexity.Trade.BuySingleFee(childComplexity), true

	case "Trade.buyerId":
		if e.complexity.Trade.BuyerID == nil {
			break
		}

		return e.complexity.Trade.BuyerID(childComplexity), true

	case "Trade.buyerOrderId":
		if e.complexity.Trade.BuyerOrderID == nil {
			break
		}

		return e.complexity.Trade.BuyerOrderID(childComplexity), true

	case "Trade.price":
		if e.complexity.Trade.Price == nil {
			break
		}

		return e.complexity.Trade.Price(childComplexity), true

	case "Trade.quantity":
		if e.complexity.Trade.Quantity == nil {
			break
		}

		return e.complexity.Trade.Quantity(childComplexity), true

	case "Trade.quoteAsset":
		if e.complexity.Trade.QuoteAsset == nil {
			break
		}

		return e.complexity.Trade.QuoteAsset(childComplexity), true

	case "Trade.sellFee":
		if e.complexity.Trade.SellFee == nil {
			break
		}

		return e.complexity.Trade.SellFee(childComplexity), true

	case "Trade.sellSingleFee":
		if e.complexity.Trade.SellSingleFee == nil {
			break
		}

		return e.complexity.Trade.SellSingleFee(childComplexity), true

	case "Trade.sellerId":
		if e.complexity.Trade.SellerID == nil {
			break
		}

		return e.complexity.Trade.SellerID(childComplexity), true

	case "Trade.sellerOrderId":
		if e.complexity.Trade.SellerOrderID == nil {
			break
		}

		return e.complexity.Trade.SellerOrderID(childComplexity), true

	case "Trade.symbol":
		if e.complexity.Trade.Symbol == nil {
			break
		}

		return e.complexity.Trade.Symbol(childComplexity), true

	case "Trade.tickType":
		if e.complexity.Trade.TickType == nil {
			break
		}

		return e.complexity.Trade.TickType(childComplexity), true

	case "Trade.time":
		if e.complexity.Trade.Time == nil {
			break
		}

		return e.complexity.Trade.Time(childComplexity), true

	case "Trade.tradeId":
		if e.complexity.Trade.TradeID == nil {
			break
		}

		return e.complexity.Trade.TradeID(childComplexity), true

	case "Transaction.blockHeight":
		if e.complexity.Transaction.BlockHeight == nil {
			break
		}

		return e.complexity.Transaction.BlockHeight(childComplexity), true

	case "Transaction.code":
		if e.complexity.Transaction.Code == nil {
			break
		}

		return e.complexity.Transaction.Code(childComplexity), true

	case "Transaction.data":
		if e.complexity.Transaction.Data == nil {
			break
		}

		return e.complexity.Transaction.Data(childComplexity), true

	case "Transaction.fromAddr":
		if e.complexity.Transaction.FromAddr == nil {
			break
		}

		return e.complexity.Transaction.FromAddr(childComplexity), true

	case "Transaction.memo":
		if e.complexity.Transaction.Memo == nil {
			break
		}

		return e.complexity.Transaction.Memo(childComplexity), true

	case "Transaction.orderId":
		if e.complexity.Transaction.OrderID == nil {
			break
		}

		return e.complexity.Transaction.OrderID(childComplexity), true

	case "Transaction.proposalId":
		if e.complexity.Transaction.ProposalID == nil {
			break
		}

		return e.complexity.Transaction.ProposalID(childComplexity), true

	case "Transaction.sequence":
		if e.complexity.Transaction.Sequence == nil {
			break
		}

		return e.complexity.Transaction.Sequence(childComplexity), true

	case "Transaction.source":
		if e.complexity.Transaction.Source == nil {
			break
		}

		return e.complexity.Transaction.Source(childComplexity), true

	case "Transaction.swapId":
		if e.complexity.Transaction.SwapID == nil {
			break
		}

		return e.complexity.Transaction.SwapID(childComplexity), true

	case "Transaction.timeStamp":
		if e.complexity.Transaction.TimeStamp == nil {
			break
		}

		return e.complexity.Transaction.TimeStamp(childComplexity), true

	case "Transaction.toAddr":
		if e.complexity.Transaction.ToAddr == nil {
			break
		}

		return e.complexity.Transaction.ToAddr(childComplexity), true

	case "Transaction.txAsset":
		if e.complexity.Transaction.TxAsset == nil {
			break
		}

		return e.complexity.Transaction.TxAsset(childComplexity), true

	case "Transaction.txFee":
		if e.complexity.Transaction.TxFee == nil {
			break
		}

		return e.complexity.Transaction.TxFee(childComplexity), true

	case "Transaction.txHash":
		if e.complexity.Transaction.TxHash == nil {
			break
		}

		return e.complexity.Transaction.TxHash(childComplexity), true

	case "Transaction.txType":
		if e.complexity.Transaction.TxType == nil {
			break
		}

		return e.complexity.Transaction.TxType(childComplexity), true

	case "Transaction.value":
		if e.complexity.Transaction.Value == nil {
			break
		}

		return e.complexity.Transaction.Value(childComplexity), true

	case "Validator.accum":
		if e.complexity.Validator.Accum == nil {
			break
		}

		return e.complexity.Validator.Accum(childComplexity), true

	case "Validator.address":
		if e.complexity.Validator.Address == nil {
			break
		}

		return e.complexity.Validator.Address(childComplexity), true

	case "Validator.pub_key":
		if e.complexity.Validator.PubKey == nil {
			break
		}

		return e.complexity.Validator.PubKey(childComplexity), true

	case "Validator.voting_power":
		if e.complexity.Validator.VotingPower == nil {
			break
		}

		return e.complexity.Validator.VotingPower(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	return graphql.ErrorResponse(ctx, "mutations are not supported")
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "../pkg/internal/schema/schema.graphql", Input: `scalar Long
scalar Number
scalar DateTime
scalar Time


type Query {
  blockStats(prove: Boolean): ProximaBlockStats
  fees(prove: Boolean): ProximaFees
  tokens(limit: Int, offset: Int, prove: Boolean): ProximaTokens
  account(address: String, prove: Boolean): ProximaAccount
  orders(address: String, symbol: String, start: String, end: String, orderSide: Int, open: Boolean, status: String, total: Int, limit: Int, offset: Int, prove: Boolean): [ProximaOrder]
  order(orderId: String, prove: Boolean): ProximaOrder
  transactions(address: String, txType: String, txAsset: String, txSide: Int, blockHeight: String, startTime: String, endTime: String, limit: Int, offset: Int, prove: Boolean): [ProximaTransaction]
  transaction(txHash: String, prove: Boolean): ProximaTransaction
  markets(limit: Int, offset: Int, prove: Boolean): ProximaMarkets
  marketTicker(symbol: String, prove: Boolean): ProximaMarketTicker
  marketTickers(limit: Int, offset: Int, prove: Boolean): ProximaMarketTickers
  marketDepth(symbol_pair: String, limit: Int, prove: Boolean): ProximaMarketDepth
  marketCandleSticks(symbol: String, startTime: String, endTime: String, interval: String, limit: Int, prove: Boolean): ProximaMarketCandleSticks
  trades(address: String, symbol: String, quoteAssetSymbol: String, blockHeight: String, startTime: String, endTime: String, buyerOrderId: String, sellerOrderId: String, orderSide: Int, limit: Int, offset: Int, prove: Boolean): [ProximaTrade]
  trade(tradeId: String, prove: Boolean): ProximaTrade
  atomicSwaps(fromAddress: String, toAddress: String, startTime: String, endTime: String, limit: Int, offset: Int, prove: Boolean): [ProximaAtomicSwap]
  atomicSwap(id: String, prove: Boolean): ProximaAtomicSwap
  validators(prove: Boolean): ProximaValidators
  timelocks(address: String, id: Int, prove: Boolean): ProximaTimelocks
}


interface ProximaModel {
  proof: Proof
}

type Proof {
  root: String
  proof: String
}

type ProximaBlockStats implements ProximaModel {
  block_stats: BlockStats
  proof: Proof
}

type BlockStats {
  latest_block_hash: String
  latest_app_hash: String
  latest_block_height:	String
  latest_block_time:	String
  catching_up:	Boolean
}

type ProximaFees implements ProximaModel {
  fees: [Fee]
  proof: Proof

}

type Fee {
  msg_type: String
  fee: Int
  fee_for: Int
  multi_transfer_fee: String
  lower_limit_as_multi: String
}

type ProximaTokens implements ProximaModel {
  tokens: [Token]
  proof: Proof

}

type Token {
  name: String
  symbol: String
  original_symbol: String
  total_supply: String
  owner: String
}

type ProximaAccount implements ProximaModel {
  account: Account
  proof: Proof

}

type Account  {
  account_number: Int
  address: String
  public_key: [Int]
  sequence: Int
  balances: [Balance]
}

type Balances {
 address: String
 balances: [Balance]
}

type Balance {
  symbol: String
  free: String
  locked: String
  frozen: String
}

type ProximaOrder implements ProximaModel {
  order: Order
  proof: Proof
}

type OrderList {
  orders: [Order]
  total: Int
}

type Order {
  cumulateQuantity: String
  fee: String
  lastExecutedPrice: String
  lastExecutedQuantity: String
  orderCreateTime: String
  orderId: String
  owner: String
  price: String
  quantity: String
  side: Int
  status: String
  symbol: String
  timeInForce: Int
  tradeId: String
  transactionHash: String
  transactionTime: String
  type: Int
}

type ProximaTransaction implements ProximaModel {
  transaction: Transaction
  proof: Proof

}

type Transaction {
  blockHeight: String
  code: Int
  data: String
  fromAddr: String
  memo: String
  orderId: String
  proposalId: String
  sequence: String
  source: String
  swapId: String
  timeStamp:	String
  toAddr:	String
  txAsset:	String
  txFee:	String
  txHash:	String
  txType:	String
  value:	String
}

type ProximaMarketCandleSticks implements ProximaModel {
  symbol: String
  interval: String
  market_candlesticks: [CandleStick]
  proof: Proof
}

type CandleStick {
  close: Float
  closingTime: String
  high: Float
  low: Float
  numberOfTrades: Int
  open: Float
  openTime: String
  quoteAssetVolume: Float
  volume: Float
}

type ProximaTrade {
  trade: Trade
  proof: Proof
}

type Trade {
  baseAsset: String
  blockHeight: String
  buyFee: String
  buyerId: String
  buyerOrderId: String
  buySingleFee: String
  price: String
  quantity: String
  quoteAsset: String
  sellFee: String
  sellerId: String
  sellerOrderId: String
  sellSingleFee: String
  symbol: String
  tickType: String
  time: String
  tradeId: String
}

type ProximaMarkets implements ProximaModel {
  markets: [Market]
  proof: Proof
}

type Market {
  base_asset_symbol: String
  quote_asset_symbol: String
  list_price: String
  tick_size: String
  lot_size: String
}

type ProximaMarketTickers implements ProximaModel {
  market_tickers: [MarketTicker]
  proof: Proof
}

type ProximaMarketTicker implements ProximaModel {
  market_ticker: MarketTicker
  proof: Proof
}

type MarketTicker {
  askPrice: String
  askQuantity: String
  bidPrice: String
  closeTime: String
  count: String
  firstId: String
  highPrice: String
  lastId: String
  lastPrice: String
  lastQuantity: String
  lowPrice: String
  openTime: String
  prevClosePrice: String
  priceChange: String
  priceChangePercent: String
  quoteVolume: String
  symbol: String
  volume: String
  weightedAvgPrice: String
}

type ProximaMarketDepth implements ProximaModel {
  market_depth: MarketDepth
  proof: Proof
}

type MarketDepth {
  symbol_pair: String
  bids: [String]
  asks: [String]
}

type ProximaAtomicSwap {
  atomic_swap: AtomicSwap
  proof: Proof
}

type AtomicSwap {
  closedTime: String
  createdTime: String
  crossChain: Int
  expectedIncome:	String
  expireHeight:	String
  fromAddr:	String
  inAmount:	String
  outAmount:	String
  randomString:	String
  randomStringHash: String
  recipientOtherChain: String
  status:	Int
  swapId:	String
  timestamp: String
  toAddr: String
  updateTime: String
}

type ProximaValidators implements ProximaModel {
  validators: [Validator]
  proof: Proof
}

type Validator {
  address: String
  pub_key: String
  voting_power: Int
  accum: Int
}

type ProximaTimelocks implements ProximaModel {
  timelocks: TimelockList
  proof: Proof
}

type TimelockList {
  timelocks: [Timelock]
}

type Timelock {
  ID: Int
  description: String
  amount: Coin
  locktime: String
}

type Coin {
  denom: String
  amount: Int
}
`},
)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_account_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["address"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["prove"]; ok {
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prove"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_atomicSwap_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["id"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["prove"]; ok {
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prove"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_atomicSwaps_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["fromAddress"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["fromAddress"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["toAddress"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["toAddress"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["startTime"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["startTime"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["endTime"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["endTime"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg4
	var arg5 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg5, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg5
	var arg6 *bool
	if tmp, ok := rawArgs["prove"]; ok {
		arg6, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prove"] = arg6
	return args, nil
}

func (ec *executionContext) field_Query_blockStats_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *bool
	if tmp, ok := rawArgs["prove"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prove"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_fees_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *bool
	if tmp, ok := rawArgs["prove"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prove"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_marketCandleSticks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["symbol"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["symbol"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["startTime"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["startTime"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["endTime"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["endTime"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["interval"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["interval"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg4
	var arg5 *bool
	if tmp, ok := rawArgs["prove"]; ok {
		arg5, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prove"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_marketDepth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["symbol_pair"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["symbol_pair"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *bool
	if tmp, ok := rawArgs["prove"]; ok {
		arg2, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prove"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_marketTicker_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["symbol"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["symbol"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["prove"]; ok {
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prove"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_marketTickers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *bool
	if tmp, ok := rawArgs["prove"]; ok {
		arg2, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prove"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_markets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *bool
	if tmp, ok := rawArgs["prove"]; ok {
		arg2, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prove"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_order_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["orderId"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderId"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["prove"]; ok {
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prove"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_orders_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["address"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["symbol"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["symbol"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["start"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["start"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["end"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["end"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["orderSide"]; ok {
		arg4, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderSide"] = arg4
	var arg5 *bool
	if tmp, ok := rawArgs["open"]; ok {
		arg5, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["open"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["status"]; ok {
		arg6, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["status"] = arg6
	var arg7 *int
	if tmp, ok := rawArgs["total"]; ok {
		arg7, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["total"] = arg7
	var arg8 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg8, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg8
	var arg9 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg9, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg9
	var arg10 *bool
	if tmp, ok := rawArgs["prove"]; ok {
		arg10, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prove"] = arg10
	return args, nil
}

func (ec *executionContext) field_Query_timelocks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["address"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["id"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg1
	var arg2 *bool
	if tmp, ok := rawArgs["prove"]; ok {
		arg2, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prove"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_tokens_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	var arg2 *bool
	if tmp, ok := rawArgs["prove"]; ok {
		arg2, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prove"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_trade_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["tradeId"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tradeId"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["prove"]; ok {
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prove"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_trades_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["address"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["symbol"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["symbol"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["quoteAssetSymbol"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["quoteAssetSymbol"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["blockHeight"]; ok {
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["blockHeight"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["startTime"]; ok {
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["startTime"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["endTime"]; ok {
		arg5, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["endTime"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["buyerOrderId"]; ok {
		arg6, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buyerOrderId"] = arg6
	var arg7 *string
	if tmp, ok := rawArgs["sellerOrderId"]; ok {
		arg7, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sellerOrderId"] = arg7
	var arg8 *int
	if tmp, ok := rawArgs["orderSide"]; ok {
		arg8, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderSide"] = arg8
	var arg9 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg9, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg9
	var arg10 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg10, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg10
	var arg11 *bool
	if tmp, ok := rawArgs["prove"]; ok {
		arg11, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prove"] = arg11
	return args, nil
}

func (ec *executionContext) field_Query_transaction_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["txHash"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["txHash"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["prove"]; ok {
		arg1, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prove"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_transactions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["address"]; ok {
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["txType"]; ok {
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["txType"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["txAsset"]; ok {
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["txAsset"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["txSide"]; ok {
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["txSide"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["blockHeight"]; ok {
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["blockHeight"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["startTime"]; ok {
		arg5, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["startTime"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["endTime"]; ok {
		arg6, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["endTime"] = arg6
	var arg7 *int
	if tmp, ok := rawArgs["limit"]; ok {
		arg7, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg7
	var arg8 *int
	if tmp, ok := rawArgs["offset"]; ok {
		arg8, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg8
	var arg9 *bool
	if tmp, ok := rawArgs["prove"]; ok {
		arg9, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prove"] = arg9
	return args, nil
}

func (ec *executionContext) field_Query_validators_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *bool
	if tmp, ok := rawArgs["prove"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["prove"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Account_account_number(ctx context.Context, field graphql.CollectedField, obj *models.Account) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Account",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_address(ctx context.Context, field graphql.CollectedField, obj *models.Account) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Account",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_public_key(ctx context.Context, field graphql.CollectedField, obj *models.Account) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Account",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublicKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_sequence(ctx context.Context, field graphql.CollectedField, obj *models.Account) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Account",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sequence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Account_balances(ctx context.Context, field graphql.CollectedField, obj *models.Account) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Account",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Balances, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Balance)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBalance2githubcomproximaonebinancechainsubgraphpkgmodelsBalance(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwap_closedTime(ctx context.Context, field graphql.CollectedField, obj *models.AtomicSwap) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwap",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClosedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwap_createdTime(ctx context.Context, field graphql.CollectedField, obj *models.AtomicSwap) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwap",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwap_crossChain(ctx context.Context, field graphql.CollectedField, obj *models.AtomicSwap) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwap",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CrossChain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwap_expectedIncome(ctx context.Context, field graphql.CollectedField, obj *models.AtomicSwap) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwap",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpectedIncome, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwap_expireHeight(ctx context.Context, field graphql.CollectedField, obj *models.AtomicSwap) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwap",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpireHeight, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwap_fromAddr(ctx context.Context, field graphql.CollectedField, obj *models.AtomicSwap) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwap",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FromAddr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwap_inAmount(ctx context.Context, field graphql.CollectedField, obj *models.AtomicSwap) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwap",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InAmount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwap_outAmount(ctx context.Context, field graphql.CollectedField, obj *models.AtomicSwap) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwap",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OutAmount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwap_randomString(ctx context.Context, field graphql.CollectedField, obj *models.AtomicSwap) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwap",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RandomString, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwap_randomStringHash(ctx context.Context, field graphql.CollectedField, obj *models.AtomicSwap) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwap",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RandomStringHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwap_recipientOtherChain(ctx context.Context, field graphql.CollectedField, obj *models.AtomicSwap) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwap",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecipientOtherChain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwap_status(ctx context.Context, field graphql.CollectedField, obj *models.AtomicSwap) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwap",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwap_swapId(ctx context.Context, field graphql.CollectedField, obj *models.AtomicSwap) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwap",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SwapID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwap_timestamp(ctx context.Context, field graphql.CollectedField, obj *models.AtomicSwap) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwap",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwap_toAddr(ctx context.Context, field graphql.CollectedField, obj *models.AtomicSwap) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwap",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToAddr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AtomicSwap_updateTime(ctx context.Context, field graphql.CollectedField, obj *models.AtomicSwap) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "AtomicSwap",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Balance_symbol(ctx context.Context, field graphql.CollectedField, obj *models.Balance) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Balance",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Symbol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Balance_free(ctx context.Context, field graphql.CollectedField, obj *models.Balance) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Balance",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Free, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Balance_locked(ctx context.Context, field graphql.CollectedField, obj *models.Balance) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Balance",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locked, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Balance_frozen(ctx context.Context, field graphql.CollectedField, obj *models.Balance) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Balance",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Frozen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Balances_address(ctx context.Context, field graphql.CollectedField, obj *models.Balances) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Balances",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Balances_balances(ctx context.Context, field graphql.CollectedField, obj *models.Balances) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Balances",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Balances, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Balance)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBalance2githubcomproximaonebinancechainsubgraphpkgmodelsBalance(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockStats_latest_block_hash(ctx context.Context, field graphql.CollectedField, obj *models.BlockStats) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BlockStats",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestBlockHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockStats_latest_app_hash(ctx context.Context, field graphql.CollectedField, obj *models.BlockStats) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BlockStats",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestAppHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockStats_latest_block_height(ctx context.Context, field graphql.CollectedField, obj *models.BlockStats) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BlockStats",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestBlockHeight, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockStats_latest_block_time(ctx context.Context, field graphql.CollectedField, obj *models.BlockStats) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BlockStats",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestBlockTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _BlockStats_catching_up(ctx context.Context, field graphql.CollectedField, obj *models.BlockStats) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "BlockStats",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CatchingUp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CandleStick_close(ctx context.Context, field graphql.CollectedField, obj *models.CandleStick) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "CandleStick",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Close, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CandleStick_closingTime(ctx context.Context, field graphql.CollectedField, obj *models.CandleStick) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "CandleStick",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClosingTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CandleStick_high(ctx context.Context, field graphql.CollectedField, obj *models.CandleStick) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "CandleStick",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.High, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CandleStick_low(ctx context.Context, field graphql.CollectedField, obj *models.CandleStick) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "CandleStick",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Low, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CandleStick_numberOfTrades(ctx context.Context, field graphql.CollectedField, obj *models.CandleStick) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "CandleStick",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumberOfTrades, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CandleStick_open(ctx context.Context, field graphql.CollectedField, obj *models.CandleStick) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "CandleStick",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Open, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CandleStick_openTime(ctx context.Context, field graphql.CollectedField, obj *models.CandleStick) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "CandleStick",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OpenTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CandleStick_quoteAssetVolume(ctx context.Context, field graphql.CollectedField, obj *models.CandleStick) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "CandleStick",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QuoteAssetVolume, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CandleStick_volume(ctx context.Context, field graphql.CollectedField, obj *models.CandleStick) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "CandleStick",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Volume, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Coin_denom(ctx context.Context, field graphql.CollectedField, obj *models.Coin) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Coin",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Denom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Coin_amount(ctx context.Context, field graphql.CollectedField, obj *models.Coin) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Coin",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Fee_msg_type(ctx context.Context, field graphql.CollectedField, obj *models.Fee) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Fee",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MsgType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Fee_fee(ctx context.Context, field graphql.CollectedField, obj *models.Fee) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Fee",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fee, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Fee_fee_for(ctx context.Context, field graphql.CollectedField, obj *models.Fee) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Fee",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeeFor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Fee_multi_transfer_fee(ctx context.Context, field graphql.CollectedField, obj *models.Fee) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Fee",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MultiTransferFee, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Fee_lower_limit_as_multi(ctx context.Context, field graphql.CollectedField, obj *models.Fee) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Fee",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LowerLimitAsMulti, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Market_base_asset_symbol(ctx context.Context, field graphql.CollectedField, obj *models.Market) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Market",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseAssetSymbol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Market_quote_asset_symbol(ctx context.Context, field graphql.CollectedField, obj *models.Market) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Market",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QuoteAssetSymbol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Market_list_price(ctx context.Context, field graphql.CollectedField, obj *models.Market) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Market",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ListPrice, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Market_tick_size(ctx context.Context, field graphql.CollectedField, obj *models.Market) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Market",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TickSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Market_lot_size(ctx context.Context, field graphql.CollectedField, obj *models.Market) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Market",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LotSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MarketDepth_symbol_pair(ctx context.Context, field graphql.CollectedField, obj *models.MarketDepth) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MarketDepth",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SymbolPair, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MarketDepth_bids(ctx context.Context, field graphql.CollectedField, obj *models.MarketDepth) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MarketDepth",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bids, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MarketDepth_asks(ctx context.Context, field graphql.CollectedField, obj *models.MarketDepth) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MarketDepth",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Asks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MarketTicker_askPrice(ctx context.Context, field graphql.CollectedField, obj *models.MarketTicker) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MarketTicker",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AskPrice, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MarketTicker_askQuantity(ctx context.Context, field graphql.CollectedField, obj *models.MarketTicker) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MarketTicker",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AskQuantity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MarketTicker_bidPrice(ctx context.Context, field graphql.CollectedField, obj *models.MarketTicker) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MarketTicker",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BidPrice, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MarketTicker_closeTime(ctx context.Context, field graphql.CollectedField, obj *models.MarketTicker) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MarketTicker",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CloseTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MarketTicker_count(ctx context.Context, field graphql.CollectedField, obj *models.MarketTicker) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MarketTicker",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MarketTicker_firstId(ctx context.Context, field graphql.CollectedField, obj *models.MarketTicker) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MarketTicker",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirstID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MarketTicker_highPrice(ctx context.Context, field graphql.CollectedField, obj *models.MarketTicker) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MarketTicker",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HighPrice, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MarketTicker_lastId(ctx context.Context, field graphql.CollectedField, obj *models.MarketTicker) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MarketTicker",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MarketTicker_lastPrice(ctx context.Context, field graphql.CollectedField, obj *models.MarketTicker) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MarketTicker",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastPrice, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MarketTicker_lastQuantity(ctx context.Context, field graphql.CollectedField, obj *models.MarketTicker) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MarketTicker",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastQuantity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MarketTicker_lowPrice(ctx context.Context, field graphql.CollectedField, obj *models.MarketTicker) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MarketTicker",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LowPrice, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MarketTicker_openTime(ctx context.Context, field graphql.CollectedField, obj *models.MarketTicker) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MarketTicker",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OpenTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MarketTicker_prevClosePrice(ctx context.Context, field graphql.CollectedField, obj *models.MarketTicker) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MarketTicker",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrevClosePrice, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MarketTicker_priceChange(ctx context.Context, field graphql.CollectedField, obj *models.MarketTicker) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MarketTicker",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PriceChange, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MarketTicker_priceChangePercent(ctx context.Context, field graphql.CollectedField, obj *models.MarketTicker) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MarketTicker",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PriceChangePercent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MarketTicker_quoteVolume(ctx context.Context, field graphql.CollectedField, obj *models.MarketTicker) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MarketTicker",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QuoteVolume, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MarketTicker_symbol(ctx context.Context, field graphql.CollectedField, obj *models.MarketTicker) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MarketTicker",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Symbol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MarketTicker_volume(ctx context.Context, field graphql.CollectedField, obj *models.MarketTicker) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MarketTicker",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Volume, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _MarketTicker_weightedAvgPrice(ctx context.Context, field graphql.CollectedField, obj *models.MarketTicker) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "MarketTicker",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WeightedAvgPrice, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Order_cumulateQuantity(ctx context.Context, field graphql.CollectedField, obj *models.Order) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Order",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CumulateQuantity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Order_fee(ctx context.Context, field graphql.CollectedField, obj *models.Order) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Order",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fee, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Order_lastExecutedPrice(ctx context.Context, field graphql.CollectedField, obj *models.Order) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Order",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastExecutedPrice, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Order_lastExecutedQuantity(ctx context.Context, field graphql.CollectedField, obj *models.Order) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Order",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastExecutedQuantity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Order_orderCreateTime(ctx context.Context, field graphql.CollectedField, obj *models.Order) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Order",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderCreateTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Order_orderId(ctx context.Context, field graphql.CollectedField, obj *models.Order) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Order",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Order_owner(ctx context.Context, field graphql.CollectedField, obj *models.Order) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Order",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Order_price(ctx context.Context, field graphql.CollectedField, obj *models.Order) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Order",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Order_quantity(ctx context.Context, field graphql.CollectedField, obj *models.Order) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Order",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Quantity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Order_side(ctx context.Context, field graphql.CollectedField, obj *models.Order) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Order",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Side, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Order_status(ctx context.Context, field graphql.CollectedField, obj *models.Order) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Order",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Order_symbol(ctx context.Context, field graphql.CollectedField, obj *models.Order) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Order",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Symbol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Order_timeInForce(ctx context.Context, field graphql.CollectedField, obj *models.Order) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Order",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeInForce, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Order_tradeId(ctx context.Context, field graphql.CollectedField, obj *models.Order) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Order",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TradeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Order_transactionHash(ctx context.Context, field graphql.CollectedField, obj *models.Order) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Order",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TransactionHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Order_transactionTime(ctx context.Context, field graphql.CollectedField, obj *models.Order) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Order",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TransactionTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Order_type(ctx context.Context, field graphql.CollectedField, obj *models.Order) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Order",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _OrderList_orders(ctx context.Context, field graphql.CollectedField, obj *models.OrderList) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "OrderList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Orders, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Order)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOOrder2githubcomproximaonebinancechainsubgraphpkgmodelsOrder(ctx, field.Selections, res)
}

func (ec *executionContext) _OrderList_total(ctx context.Context, field graphql.CollectedField, obj *models.OrderList) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "OrderList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Proof_root(ctx context.Context, field graphql.CollectedField, obj *models.Proof) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Proof",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Root, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Proof_proof(ctx context.Context, field graphql.CollectedField, obj *models.Proof) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Proof",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proof, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaAccount_account(ctx context.Context, field graphql.CollectedField, obj *models.ProximaAccount) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaAccount",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Account, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Account)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOAccount2githubcomproximaonebinancechainsubgraphpkgmodelsAccount(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaAccount_proof(ctx context.Context, field graphql.CollectedField, obj *models.ProximaAccount) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaAccount",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proof, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Proof)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProof2githubcomproximaonebinancechainsubgraphpkgmodelsProof(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaAtomicSwap_atomic_swap(ctx context.Context, field graphql.CollectedField, obj *models.ProximaAtomicSwap) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaAtomicSwap",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AtomicSwap, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.AtomicSwap)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOAtomicSwap2githubcomproximaonebinancechainsubgraphpkgmodelsAtomicSwap(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaAtomicSwap_proof(ctx context.Context, field graphql.CollectedField, obj *models.ProximaAtomicSwap) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaAtomicSwap",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proof, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Proof)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProof2githubcomproximaonebinancechainsubgraphpkgmodelsProof(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaBlockStats_block_stats(ctx context.Context, field graphql.CollectedField, obj *models.ProximaBlockStats) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaBlockStats",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockStats, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.BlockStats)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBlockStats2githubcomproximaonebinancechainsubgraphpkgmodelsBlockStats(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaBlockStats_proof(ctx context.Context, field graphql.CollectedField, obj *models.ProximaBlockStats) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaBlockStats",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proof, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Proof)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProof2githubcomproximaonebinancechainsubgraphpkgmodelsProof(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaFees_fees(ctx context.Context, field graphql.CollectedField, obj *models.ProximaFees) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaFees",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fees, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Fee)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOFee2githubcomproximaonebinancechainsubgraphpkgmodelsFee(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaFees_proof(ctx context.Context, field graphql.CollectedField, obj *models.ProximaFees) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaFees",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proof, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Proof)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProof2githubcomproximaonebinancechainsubgraphpkgmodelsProof(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaMarketCandleSticks_symbol(ctx context.Context, field graphql.CollectedField, obj *models.ProximaMarketCandleSticks) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaMarketCandleSticks",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Symbol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaMarketCandleSticks_interval(ctx context.Context, field graphql.CollectedField, obj *models.ProximaMarketCandleSticks) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaMarketCandleSticks",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interval, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaMarketCandleSticks_market_candlesticks(ctx context.Context, field graphql.CollectedField, obj *models.ProximaMarketCandleSticks) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaMarketCandleSticks",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MarketCandlesticks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.CandleStick)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOCandleStick2githubcomproximaonebinancechainsubgraphpkgmodelsCandleStick(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaMarketCandleSticks_proof(ctx context.Context, field graphql.CollectedField, obj *models.ProximaMarketCandleSticks) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaMarketCandleSticks",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proof, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Proof)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProof2githubcomproximaonebinancechainsubgraphpkgmodelsProof(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaMarketDepth_market_depth(ctx context.Context, field graphql.CollectedField, obj *models.ProximaMarketDepth) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaMarketDepth",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MarketDepth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MarketDepth)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOMarketDepth2githubcomproximaonebinancechainsubgraphpkgmodelsMarketDepth(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaMarketDepth_proof(ctx context.Context, field graphql.CollectedField, obj *models.ProximaMarketDepth) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaMarketDepth",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proof, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Proof)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProof2githubcomproximaonebinancechainsubgraphpkgmodelsProof(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaMarketTicker_market_ticker(ctx context.Context, field graphql.CollectedField, obj *models.ProximaMarketTicker) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaMarketTicker",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MarketTicker, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MarketTicker)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOMarketTicker2githubcomproximaonebinancechainsubgraphpkgmodelsMarketTicker(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaMarketTicker_proof(ctx context.Context, field graphql.CollectedField, obj *models.ProximaMarketTicker) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaMarketTicker",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proof, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Proof)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProof2githubcomproximaonebinancechainsubgraphpkgmodelsProof(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaMarketTickers_market_tickers(ctx context.Context, field graphql.CollectedField, obj *models.ProximaMarketTickers) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaMarketTickers",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MarketTickers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.MarketTicker)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOMarketTicker2githubcomproximaonebinancechainsubgraphpkgmodelsMarketTicker(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaMarketTickers_proof(ctx context.Context, field graphql.CollectedField, obj *models.ProximaMarketTickers) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaMarketTickers",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proof, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Proof)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProof2githubcomproximaonebinancechainsubgraphpkgmodelsProof(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaMarkets_markets(ctx context.Context, field graphql.CollectedField, obj *models.ProximaMarkets) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaMarkets",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Markets, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Market)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOMarket2githubcomproximaonebinancechainsubgraphpkgmodelsMarket(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaMarkets_proof(ctx context.Context, field graphql.CollectedField, obj *models.ProximaMarkets) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaMarkets",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proof, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Proof)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProof2githubcomproximaonebinancechainsubgraphpkgmodelsProof(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaOrder_order(ctx context.Context, field graphql.CollectedField, obj *models.ProximaOrder) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaOrder",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Order, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Order)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOOrder2githubcomproximaonebinancechainsubgraphpkgmodelsOrder(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaOrder_proof(ctx context.Context, field graphql.CollectedField, obj *models.ProximaOrder) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaOrder",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proof, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Proof)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProof2githubcomproximaonebinancechainsubgraphpkgmodelsProof(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaTimelocks_timelocks(ctx context.Context, field graphql.CollectedField, obj *models.ProximaTimelocks) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaTimelocks",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timelocks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.TimelockList)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTimelockList2githubcomproximaonebinancechainsubgraphpkgmodelsTimelockList(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaTimelocks_proof(ctx context.Context, field graphql.CollectedField, obj *models.ProximaTimelocks) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaTimelocks",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proof, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Proof)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProof2githubcomproximaonebinancechainsubgraphpkgmodelsProof(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaTokens_tokens(ctx context.Context, field graphql.CollectedField, obj *models.ProximaTokens) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaTokens",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tokens, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Token)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOToken2githubcomproximaonebinancechainsubgraphpkgmodelsToken(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaTokens_proof(ctx context.Context, field graphql.CollectedField, obj *models.ProximaTokens) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaTokens",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proof, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Proof)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProof2githubcomproximaonebinancechainsubgraphpkgmodelsProof(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaTrade_trade(ctx context.Context, field graphql.CollectedField, obj *models.ProximaTrade) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaTrade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Trade, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Trade)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTrade2githubcomproximaonebinancechainsubgraphpkgmodelsTrade(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaTrade_proof(ctx context.Context, field graphql.CollectedField, obj *models.ProximaTrade) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaTrade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proof, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Proof)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProof2githubcomproximaonebinancechainsubgraphpkgmodelsProof(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaTransaction_transaction(ctx context.Context, field graphql.CollectedField, obj *models.ProximaTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Transaction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Transaction)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTransaction2githubcomproximaonebinancechainsubgraphpkgmodelsTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaTransaction_proof(ctx context.Context, field graphql.CollectedField, obj *models.ProximaTransaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proof, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Proof)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProof2githubcomproximaonebinancechainsubgraphpkgmodelsProof(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaValidators_validators(ctx context.Context, field graphql.CollectedField, obj *models.ProximaValidators) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaValidators",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Validators, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Validator)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOValidator2githubcomproximaonebinancechainsubgraphpkgmodelsValidator(ctx, field.Selections, res)
}

func (ec *executionContext) _ProximaValidators_proof(ctx context.Context, field graphql.CollectedField, obj *models.ProximaValidators) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "ProximaValidators",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proof, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Proof)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProof2githubcomproximaonebinancechainsubgraphpkgmodelsProof(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_blockStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_blockStats_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BlockStats(rctx, args["prove"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ProximaBlockStats)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProximaBlockStats2githubcomproximaonebinancechainsubgraphpkgmodelsProximaBlockStats(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_fees(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_fees_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Fees(rctx, args["prove"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ProximaFees)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProximaFees2githubcomproximaonebinancechainsubgraphpkgmodelsProximaFees(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_tokens(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_tokens_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Tokens(rctx, args["limit"].(*int), args["offset"].(*int), args["prove"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ProximaTokens)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProximaTokens2githubcomproximaonebinancechainsubgraphpkgmodelsProximaTokens(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_account(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_account_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Account(rctx, args["address"].(*string), args["prove"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ProximaAccount)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProximaAccount2githubcomproximaonebinancechainsubgraphpkgmodelsProximaAccount(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_orders(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_orders_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Orders(rctx, args["address"].(*string), args["symbol"].(*string), args["start"].(*string), args["end"].(*string), args["orderSide"].(*int), args["open"].(*bool), args["status"].(*string), args["total"].(*int), args["limit"].(*int), args["offset"].(*int), args["prove"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ProximaOrder)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProximaOrder2githubcomproximaonebinancechainsubgraphpkgmodelsProximaOrder(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_order(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_order_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Order(rctx, args["orderId"].(*string), args["prove"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ProximaOrder)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProximaOrder2githubcomproximaonebinancechainsubgraphpkgmodelsProximaOrder(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_transactions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_transactions_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Transactions(rctx, args["address"].(*string), args["txType"].(*string), args["txAsset"].(*string), args["txSide"].(*int), args["blockHeight"].(*string), args["startTime"].(*string), args["endTime"].(*string), args["limit"].(*int), args["offset"].(*int), args["prove"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ProximaTransaction)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProximaTransaction2githubcomproximaonebinancechainsubgraphpkgmodelsProximaTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_transaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_transaction_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Transaction(rctx, args["txHash"].(*string), args["prove"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ProximaTransaction)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProximaTransaction2githubcomproximaonebinancechainsubgraphpkgmodelsProximaTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_markets(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_markets_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Markets(rctx, args["limit"].(*int), args["offset"].(*int), args["prove"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ProximaMarkets)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProximaMarkets2githubcomproximaonebinancechainsubgraphpkgmodelsProximaMarkets(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_marketTicker(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_marketTicker_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MarketTicker(rctx, args["symbol"].(*string), args["prove"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ProximaMarketTicker)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProximaMarketTicker2githubcomproximaonebinancechainsubgraphpkgmodelsProximaMarketTicker(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_marketTickers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_marketTickers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MarketTickers(rctx, args["limit"].(*int), args["offset"].(*int), args["prove"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ProximaMarketTickers)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProximaMarketTickers2githubcomproximaonebinancechainsubgraphpkgmodelsProximaMarketTickers(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_marketDepth(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_marketDepth_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MarketDepth(rctx, args["symbol_pair"].(*string), args["limit"].(*int), args["prove"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ProximaMarketDepth)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProximaMarketDepth2githubcomproximaonebinancechainsubgraphpkgmodelsProximaMarketDepth(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_marketCandleSticks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_marketCandleSticks_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MarketCandleSticks(rctx, args["symbol"].(*string), args["startTime"].(*string), args["endTime"].(*string), args["interval"].(*string), args["limit"].(*int), args["prove"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ProximaMarketCandleSticks)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProximaMarketCandleSticks2githubcomproximaonebinancechainsubgraphpkgmodelsProximaMarketCandleSticks(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_trades(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_trades_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Trades(rctx, args["address"].(*string), args["symbol"].(*string), args["quoteAssetSymbol"].(*string), args["blockHeight"].(*string), args["startTime"].(*string), args["endTime"].(*string), args["buyerOrderId"].(*string), args["sellerOrderId"].(*string), args["orderSide"].(*int), args["limit"].(*int), args["offset"].(*int), args["prove"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ProximaTrade)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProximaTrade2githubcomproximaonebinancechainsubgraphpkgmodelsProximaTrade(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_trade(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_trade_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Trade(rctx, args["tradeId"].(*string), args["prove"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ProximaTrade)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProximaTrade2githubcomproximaonebinancechainsubgraphpkgmodelsProximaTrade(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_atomicSwaps(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_atomicSwaps_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AtomicSwaps(rctx, args["fromAddress"].(*string), args["toAddress"].(*string), args["startTime"].(*string), args["endTime"].(*string), args["limit"].(*int), args["offset"].(*int), args["prove"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ProximaAtomicSwap)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProximaAtomicSwap2githubcomproximaonebinancechainsubgraphpkgmodelsProximaAtomicSwap(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_atomicSwap(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_atomicSwap_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AtomicSwap(rctx, args["id"].(*string), args["prove"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ProximaAtomicSwap)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProximaAtomicSwap2githubcomproximaonebinancechainsubgraphpkgmodelsProximaAtomicSwap(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_validators(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_validators_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Validators(rctx, args["prove"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ProximaValidators)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProximaValidators2githubcomproximaonebinancechainsubgraphpkgmodelsProximaValidators(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_timelocks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_timelocks_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Timelocks(rctx, args["address"].(*string), args["id"].(*int), args["prove"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ProximaTimelocks)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOProximaTimelocks2githubcomproximaonebinancechainsubgraphpkgmodelsProximaTimelocks(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _Timelock_ID(ctx context.Context, field graphql.CollectedField, obj *models.Timelock) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Timelock",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Timelock_description(ctx context.Context, field graphql.CollectedField, obj *models.Timelock) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Timelock",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Timelock_amount(ctx context.Context, field graphql.CollectedField, obj *models.Timelock) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Timelock",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Coin)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOCoin2githubcomproximaonebinancechainsubgraphpkgmodelsCoin(ctx, field.Selections, res)
}

func (ec *executionContext) _Timelock_locktime(ctx context.Context, field graphql.CollectedField, obj *models.Timelock) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Timelock",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locktime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _TimelockList_timelocks(ctx context.Context, field graphql.CollectedField, obj *models.TimelockList) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "TimelockList",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timelocks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Timelock)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOTimelock2githubcomproximaonebinancechainsubgraphpkgmodelsTimelock(ctx, field.Selections, res)
}

func (ec *executionContext) _Token_name(ctx context.Context, field graphql.CollectedField, obj *models.Token) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Token",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Token_symbol(ctx context.Context, field graphql.CollectedField, obj *models.Token) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Token",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Symbol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Token_original_symbol(ctx context.Context, field graphql.CollectedField, obj *models.Token) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Token",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OriginalSymbol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Token_total_supply(ctx context.Context, field graphql.CollectedField, obj *models.Token) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Token",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalSupply, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Token_owner(ctx context.Context, field graphql.CollectedField, obj *models.Token) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Token",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_baseAsset(ctx context.Context, field graphql.CollectedField, obj *models.Trade) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseAsset, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_blockHeight(ctx context.Context, field graphql.CollectedField, obj *models.Trade) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockHeight, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_buyFee(ctx context.Context, field graphql.CollectedField, obj *models.Trade) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuyFee, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_buyerId(ctx context.Context, field graphql.CollectedField, obj *models.Trade) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuyerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_buyerOrderId(ctx context.Context, field graphql.CollectedField, obj *models.Trade) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuyerOrderID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_buySingleFee(ctx context.Context, field graphql.CollectedField, obj *models.Trade) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuySingleFee, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_price(ctx context.Context, field graphql.CollectedField, obj *models.Trade) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_quantity(ctx context.Context, field graphql.CollectedField, obj *models.Trade) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Quantity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_quoteAsset(ctx context.Context, field graphql.CollectedField, obj *models.Trade) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QuoteAsset, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_sellFee(ctx context.Context, field graphql.CollectedField, obj *models.Trade) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SellFee, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_sellerId(ctx context.Context, field graphql.CollectedField, obj *models.Trade) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SellerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_sellerOrderId(ctx context.Context, field graphql.CollectedField, obj *models.Trade) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SellerOrderID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_sellSingleFee(ctx context.Context, field graphql.CollectedField, obj *models.Trade) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SellSingleFee, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_symbol(ctx context.Context, field graphql.CollectedField, obj *models.Trade) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Symbol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_tickType(ctx context.Context, field graphql.CollectedField, obj *models.Trade) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TickType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_time(ctx context.Context, field graphql.CollectedField, obj *models.Trade) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Time, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Trade_tradeId(ctx context.Context, field graphql.CollectedField, obj *models.Trade) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Trade",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TradeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_blockHeight(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Transaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockHeight, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_code(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Transaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_data(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Transaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_fromAddr(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Transaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FromAddr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_memo(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Transaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Memo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_orderId(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Transaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_proposalId(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Transaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProposalID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_sequence(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Transaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sequence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_source(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Transaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_swapId(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Transaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SwapID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_timeStamp(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Transaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeStamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_toAddr(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Transaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToAddr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_txAsset(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Transaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxAsset, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_txFee(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Transaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxFee, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_txHash(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Transaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_txType(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Transaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transaction_value(ctx context.Context, field graphql.CollectedField, obj *models.Transaction) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Transaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Validator_address(ctx context.Context, field graphql.CollectedField, obj *models.Validator) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Validator",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Validator_pub_key(ctx context.Context, field graphql.CollectedField, obj *models.Validator) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Validator",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PubKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Validator_voting_power(ctx context.Context, field graphql.CollectedField, obj *models.Validator) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Validator",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VotingPower, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Validator_accum(ctx context.Context, field graphql.CollectedField, obj *models.Validator) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "Validator",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Accum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
		ec.Tracer.EndFieldExecution(ctx)
	}()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _ProximaModel(ctx context.Context, sel ast.SelectionSet, obj models.ProximaModel) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case models.ProximaBlockStats:
		return ec._ProximaBlockStats(ctx, sel, &obj)
	case *models.ProximaBlockStats:
		return ec._ProximaBlockStats(ctx, sel, obj)
	case models.ProximaFees:
		return ec._ProximaFees(ctx, sel, &obj)
	case *models.ProximaFees:
		return ec._ProximaFees(ctx, sel, obj)
	case models.ProximaTokens:
		return ec._ProximaTokens(ctx, sel, &obj)
	case *models.ProximaTokens:
		return ec._ProximaTokens(ctx, sel, obj)
	case models.ProximaAccount:
		return ec._ProximaAccount(ctx, sel, &obj)
	case *models.ProximaAccount:
		return ec._ProximaAccount(ctx, sel, obj)
	case models.ProximaOrder:
		return ec._ProximaOrder(ctx, sel, &obj)
	case *models.ProximaOrder:
		return ec._ProximaOrder(ctx, sel, obj)
	case models.ProximaTransaction:
		return ec._ProximaTransaction(ctx, sel, &obj)
	case *models.ProximaTransaction:
		return ec._ProximaTransaction(ctx, sel, obj)
	case models.ProximaMarketCandleSticks:
		return ec._ProximaMarketCandleSticks(ctx, sel, &obj)
	case *models.ProximaMarketCandleSticks:
		return ec._ProximaMarketCandleSticks(ctx, sel, obj)
	case models.ProximaMarkets:
		return ec._ProximaMarkets(ctx, sel, &obj)
	case *models.ProximaMarkets:
		return ec._ProximaMarkets(ctx, sel, obj)
	case models.ProximaMarketTickers:
		return ec._ProximaMarketTickers(ctx, sel, &obj)
	case *models.ProximaMarketTickers:
		return ec._ProximaMarketTickers(ctx, sel, obj)
	case models.ProximaMarketTicker:
		return ec._ProximaMarketTicker(ctx, sel, &obj)
	case *models.ProximaMarketTicker:
		return ec._ProximaMarketTicker(ctx, sel, obj)
	case models.ProximaMarketDepth:
		return ec._ProximaMarketDepth(ctx, sel, &obj)
	case *models.ProximaMarketDepth:
		return ec._ProximaMarketDepth(ctx, sel, obj)
	case models.ProximaValidators:
		return ec._ProximaValidators(ctx, sel, &obj)
	case *models.ProximaValidators:
		return ec._ProximaValidators(ctx, sel, obj)
	case models.ProximaTimelocks:
		return ec._ProximaTimelocks(ctx, sel, &obj)
	case *models.ProximaTimelocks:
		return ec._ProximaTimelocks(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var accountImplementors = []string{"Account"}

func (ec *executionContext) _Account(ctx context.Context, sel ast.SelectionSet, obj *models.Account) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, accountImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Account")
		case "account_number":
			out.Values[i] = ec._Account_account_number(ctx, field, obj)
		case "address":
			out.Values[i] = ec._Account_address(ctx, field, obj)
		case "public_key":
			out.Values[i] = ec._Account_public_key(ctx, field, obj)
		case "sequence":
			out.Values[i] = ec._Account_sequence(ctx, field, obj)
		case "balances":
			out.Values[i] = ec._Account_balances(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var atomicSwapImplementors = []string{"AtomicSwap"}

func (ec *executionContext) _AtomicSwap(ctx context.Context, sel ast.SelectionSet, obj *models.AtomicSwap) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, atomicSwapImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AtomicSwap")
		case "closedTime":
			out.Values[i] = ec._AtomicSwap_closedTime(ctx, field, obj)
		case "createdTime":
			out.Values[i] = ec._AtomicSwap_createdTime(ctx, field, obj)
		case "crossChain":
			out.Values[i] = ec._AtomicSwap_crossChain(ctx, field, obj)
		case "expectedIncome":
			out.Values[i] = ec._AtomicSwap_expectedIncome(ctx, field, obj)
		case "expireHeight":
			out.Values[i] = ec._AtomicSwap_expireHeight(ctx, field, obj)
		case "fromAddr":
			out.Values[i] = ec._AtomicSwap_fromAddr(ctx, field, obj)
		case "inAmount":
			out.Values[i] = ec._AtomicSwap_inAmount(ctx, field, obj)
		case "outAmount":
			out.Values[i] = ec._AtomicSwap_outAmount(ctx, field, obj)
		case "randomString":
			out.Values[i] = ec._AtomicSwap_randomString(ctx, field, obj)
		case "randomStringHash":
			out.Values[i] = ec._AtomicSwap_randomStringHash(ctx, field, obj)
		case "recipientOtherChain":
			out.Values[i] = ec._AtomicSwap_recipientOtherChain(ctx, field, obj)
		case "status":
			out.Values[i] = ec._AtomicSwap_status(ctx, field, obj)
		case "swapId":
			out.Values[i] = ec._AtomicSwap_swapId(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._AtomicSwap_timestamp(ctx, field, obj)
		case "toAddr":
			out.Values[i] = ec._AtomicSwap_toAddr(ctx, field, obj)
		case "updateTime":
			out.Values[i] = ec._AtomicSwap_updateTime(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var balanceImplementors = []string{"Balance"}

func (ec *executionContext) _Balance(ctx context.Context, sel ast.SelectionSet, obj *models.Balance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, balanceImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Balance")
		case "symbol":
			out.Values[i] = ec._Balance_symbol(ctx, field, obj)
		case "free":
			out.Values[i] = ec._Balance_free(ctx, field, obj)
		case "locked":
			out.Values[i] = ec._Balance_locked(ctx, field, obj)
		case "frozen":
			out.Values[i] = ec._Balance_frozen(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var balancesImplementors = []string{"Balances"}

func (ec *executionContext) _Balances(ctx context.Context, sel ast.SelectionSet, obj *models.Balances) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, balancesImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Balances")
		case "address":
			out.Values[i] = ec._Balances_address(ctx, field, obj)
		case "balances":
			out.Values[i] = ec._Balances_balances(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var blockStatsImplementors = []string{"BlockStats"}

func (ec *executionContext) _BlockStats(ctx context.Context, sel ast.SelectionSet, obj *models.BlockStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, blockStatsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BlockStats")
		case "latest_block_hash":
			out.Values[i] = ec._BlockStats_latest_block_hash(ctx, field, obj)
		case "latest_app_hash":
			out.Values[i] = ec._BlockStats_latest_app_hash(ctx, field, obj)
		case "latest_block_height":
			out.Values[i] = ec._BlockStats_latest_block_height(ctx, field, obj)
		case "latest_block_time":
			out.Values[i] = ec._BlockStats_latest_block_time(ctx, field, obj)
		case "catching_up":
			out.Values[i] = ec._BlockStats_catching_up(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var candleStickImplementors = []string{"CandleStick"}

func (ec *executionContext) _CandleStick(ctx context.Context, sel ast.SelectionSet, obj *models.CandleStick) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, candleStickImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CandleStick")
		case "close":
			out.Values[i] = ec._CandleStick_close(ctx, field, obj)
		case "closingTime":
			out.Values[i] = ec._CandleStick_closingTime(ctx, field, obj)
		case "high":
			out.Values[i] = ec._CandleStick_high(ctx, field, obj)
		case "low":
			out.Values[i] = ec._CandleStick_low(ctx, field, obj)
		case "numberOfTrades":
			out.Values[i] = ec._CandleStick_numberOfTrades(ctx, field, obj)
		case "open":
			out.Values[i] = ec._CandleStick_open(ctx, field, obj)
		case "openTime":
			out.Values[i] = ec._CandleStick_openTime(ctx, field, obj)
		case "quoteAssetVolume":
			out.Values[i] = ec._CandleStick_quoteAssetVolume(ctx, field, obj)
		case "volume":
			out.Values[i] = ec._CandleStick_volume(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinImplementors = []string{"Coin"}

func (ec *executionContext) _Coin(ctx context.Context, sel ast.SelectionSet, obj *models.Coin) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, coinImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Coin")
		case "denom":
			out.Values[i] = ec._Coin_denom(ctx, field, obj)
		case "amount":
			out.Values[i] = ec._Coin_amount(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var feeImplementors = []string{"Fee"}

func (ec *executionContext) _Fee(ctx context.Context, sel ast.SelectionSet, obj *models.Fee) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, feeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Fee")
		case "msg_type":
			out.Values[i] = ec._Fee_msg_type(ctx, field, obj)
		case "fee":
			out.Values[i] = ec._Fee_fee(ctx, field, obj)
		case "fee_for":
			out.Values[i] = ec._Fee_fee_for(ctx, field, obj)
		case "multi_transfer_fee":
			out.Values[i] = ec._Fee_multi_transfer_fee(ctx, field, obj)
		case "lower_limit_as_multi":
			out.Values[i] = ec._Fee_lower_limit_as_multi(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var marketImplementors = []string{"Market"}

func (ec *executionContext) _Market(ctx context.Context, sel ast.SelectionSet, obj *models.Market) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, marketImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Market")
		case "base_asset_symbol":
			out.Values[i] = ec._Market_base_asset_symbol(ctx, field, obj)
		case "quote_asset_symbol":
			out.Values[i] = ec._Market_quote_asset_symbol(ctx, field, obj)
		case "list_price":
			out.Values[i] = ec._Market_list_price(ctx, field, obj)
		case "tick_size":
			out.Values[i] = ec._Market_tick_size(ctx, field, obj)
		case "lot_size":
			out.Values[i] = ec._Market_lot_size(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var marketDepthImplementors = []string{"MarketDepth"}

func (ec *executionContext) _MarketDepth(ctx context.Context, sel ast.SelectionSet, obj *models.MarketDepth) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, marketDepthImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MarketDepth")
		case "symbol_pair":
			out.Values[i] = ec._MarketDepth_symbol_pair(ctx, field, obj)
		case "bids":
			out.Values[i] = ec._MarketDepth_bids(ctx, field, obj)
		case "asks":
			out.Values[i] = ec._MarketDepth_asks(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var marketTickerImplementors = []string{"MarketTicker"}

func (ec *executionContext) _MarketTicker(ctx context.Context, sel ast.SelectionSet, obj *models.MarketTicker) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, marketTickerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MarketTicker")
		case "askPrice":
			out.Values[i] = ec._MarketTicker_askPrice(ctx, field, obj)
		case "askQuantity":
			out.Values[i] = ec._MarketTicker_askQuantity(ctx, field, obj)
		case "bidPrice":
			out.Values[i] = ec._MarketTicker_bidPrice(ctx, field, obj)
		case "closeTime":
			out.Values[i] = ec._MarketTicker_closeTime(ctx, field, obj)
		case "count":
			out.Values[i] = ec._MarketTicker_count(ctx, field, obj)
		case "firstId":
			out.Values[i] = ec._MarketTicker_firstId(ctx, field, obj)
		case "highPrice":
			out.Values[i] = ec._MarketTicker_highPrice(ctx, field, obj)
		case "lastId":
			out.Values[i] = ec._MarketTicker_lastId(ctx, field, obj)
		case "lastPrice":
			out.Values[i] = ec._MarketTicker_lastPrice(ctx, field, obj)
		case "lastQuantity":
			out.Values[i] = ec._MarketTicker_lastQuantity(ctx, field, obj)
		case "lowPrice":
			out.Values[i] = ec._MarketTicker_lowPrice(ctx, field, obj)
		case "openTime":
			out.Values[i] = ec._MarketTicker_openTime(ctx, field, obj)
		case "prevClosePrice":
			out.Values[i] = ec._MarketTicker_prevClosePrice(ctx, field, obj)
		case "priceChange":
			out.Values[i] = ec._MarketTicker_priceChange(ctx, field, obj)
		case "priceChangePercent":
			out.Values[i] = ec._MarketTicker_priceChangePercent(ctx, field, obj)
		case "quoteVolume":
			out.Values[i] = ec._MarketTicker_quoteVolume(ctx, field, obj)
		case "symbol":
			out.Values[i] = ec._MarketTicker_symbol(ctx, field, obj)
		case "volume":
			out.Values[i] = ec._MarketTicker_volume(ctx, field, obj)
		case "weightedAvgPrice":
			out.Values[i] = ec._MarketTicker_weightedAvgPrice(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var orderImplementors = []string{"Order"}

func (ec *executionContext) _Order(ctx context.Context, sel ast.SelectionSet, obj *models.Order) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, orderImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Order")
		case "cumulateQuantity":
			out.Values[i] = ec._Order_cumulateQuantity(ctx, field, obj)
		case "fee":
			out.Values[i] = ec._Order_fee(ctx, field, obj)
		case "lastExecutedPrice":
			out.Values[i] = ec._Order_lastExecutedPrice(ctx, field, obj)
		case "lastExecutedQuantity":
			out.Values[i] = ec._Order_lastExecutedQuantity(ctx, field, obj)
		case "orderCreateTime":
			out.Values[i] = ec._Order_orderCreateTime(ctx, field, obj)
		case "orderId":
			out.Values[i] = ec._Order_orderId(ctx, field, obj)
		case "owner":
			out.Values[i] = ec._Order_owner(ctx, field, obj)
		case "price":
			out.Values[i] = ec._Order_price(ctx, field, obj)
		case "quantity":
			out.Values[i] = ec._Order_quantity(ctx, field, obj)
		case "side":
			out.Values[i] = ec._Order_side(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Order_status(ctx, field, obj)
		case "symbol":
			out.Values[i] = ec._Order_symbol(ctx, field, obj)
		case "timeInForce":
			out.Values[i] = ec._Order_timeInForce(ctx, field, obj)
		case "tradeId":
			out.Values[i] = ec._Order_tradeId(ctx, field, obj)
		case "transactionHash":
			out.Values[i] = ec._Order_transactionHash(ctx, field, obj)
		case "transactionTime":
			out.Values[i] = ec._Order_transactionTime(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Order_type(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var orderListImplementors = []string{"OrderList"}

func (ec *executionContext) _OrderList(ctx context.Context, sel ast.SelectionSet, obj *models.OrderList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, orderListImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OrderList")
		case "orders":
			out.Values[i] = ec._OrderList_orders(ctx, field, obj)
		case "total":
			out.Values[i] = ec._OrderList_total(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var proofImplementors = []string{"Proof"}

func (ec *executionContext) _Proof(ctx context.Context, sel ast.SelectionSet, obj *models.Proof) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, proofImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Proof")
		case "root":
			out.Values[i] = ec._Proof_root(ctx, field, obj)
		case "proof":
			out.Values[i] = ec._Proof_proof(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var proximaAccountImplementors = []string{"ProximaAccount", "ProximaModel"}

func (ec *executionContext) _ProximaAccount(ctx context.Context, sel ast.SelectionSet, obj *models.ProximaAccount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, proximaAccountImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProximaAccount")
		case "account":
			out.Values[i] = ec._ProximaAccount_account(ctx, field, obj)
		case "proof":
			out.Values[i] = ec._ProximaAccount_proof(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var proximaAtomicSwapImplementors = []string{"ProximaAtomicSwap"}

func (ec *executionContext) _ProximaAtomicSwap(ctx context.Context, sel ast.SelectionSet, obj *models.ProximaAtomicSwap) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, proximaAtomicSwapImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProximaAtomicSwap")
		case "atomic_swap":
			out.Values[i] = ec._ProximaAtomicSwap_atomic_swap(ctx, field, obj)
		case "proof":
			out.Values[i] = ec._ProximaAtomicSwap_proof(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var proximaBlockStatsImplementors = []string{"ProximaBlockStats", "ProximaModel"}

func (ec *executionContext) _ProximaBlockStats(ctx context.Context, sel ast.SelectionSet, obj *models.ProximaBlockStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, proximaBlockStatsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProximaBlockStats")
		case "block_stats":
			out.Values[i] = ec._ProximaBlockStats_block_stats(ctx, field, obj)
		case "proof":
			out.Values[i] = ec._ProximaBlockStats_proof(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var proximaFeesImplementors = []string{"ProximaFees", "ProximaModel"}

func (ec *executionContext) _ProximaFees(ctx context.Context, sel ast.SelectionSet, obj *models.ProximaFees) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, proximaFeesImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProximaFees")
		case "fees":
			out.Values[i] = ec._ProximaFees_fees(ctx, field, obj)
		case "proof":
			out.Values[i] = ec._ProximaFees_proof(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var proximaMarketCandleSticksImplementors = []string{"ProximaMarketCandleSticks", "ProximaModel"}

func (ec *executionContext) _ProximaMarketCandleSticks(ctx context.Context, sel ast.SelectionSet, obj *models.ProximaMarketCandleSticks) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, proximaMarketCandleSticksImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProximaMarketCandleSticks")
		case "symbol":
			out.Values[i] = ec._ProximaMarketCandleSticks_symbol(ctx, field, obj)
		case "interval":
			out.Values[i] = ec._ProximaMarketCandleSticks_interval(ctx, field, obj)
		case "market_candlesticks":
			out.Values[i] = ec._ProximaMarketCandleSticks_market_candlesticks(ctx, field, obj)
		case "proof":
			out.Values[i] = ec._ProximaMarketCandleSticks_proof(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var proximaMarketDepthImplementors = []string{"ProximaMarketDepth", "ProximaModel"}

func (ec *executionContext) _ProximaMarketDepth(ctx context.Context, sel ast.SelectionSet, obj *models.ProximaMarketDepth) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, proximaMarketDepthImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProximaMarketDepth")
		case "market_depth":
			out.Values[i] = ec._ProximaMarketDepth_market_depth(ctx, field, obj)
		case "proof":
			out.Values[i] = ec._ProximaMarketDepth_proof(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var proximaMarketTickerImplementors = []string{"ProximaMarketTicker", "ProximaModel"}

func (ec *executionContext) _ProximaMarketTicker(ctx context.Context, sel ast.SelectionSet, obj *models.ProximaMarketTicker) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, proximaMarketTickerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProximaMarketTicker")
		case "market_ticker":
			out.Values[i] = ec._ProximaMarketTicker_market_ticker(ctx, field, obj)
		case "proof":
			out.Values[i] = ec._ProximaMarketTicker_proof(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var proximaMarketTickersImplementors = []string{"ProximaMarketTickers", "ProximaModel"}

func (ec *executionContext) _ProximaMarketTickers(ctx context.Context, sel ast.SelectionSet, obj *models.ProximaMarketTickers) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, proximaMarketTickersImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProximaMarketTickers")
		case "market_tickers":
			out.Values[i] = ec._ProximaMarketTickers_market_tickers(ctx, field, obj)
		case "proof":
			out.Values[i] = ec._ProximaMarketTickers_proof(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var proximaMarketsImplementors = []string{"ProximaMarkets", "ProximaModel"}

func (ec *executionContext) _ProximaMarkets(ctx context.Context, sel ast.SelectionSet, obj *models.ProximaMarkets) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, proximaMarketsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProximaMarkets")
		case "markets":
			out.Values[i] = ec._ProximaMarkets_markets(ctx, field, obj)
		case "proof":
			out.Values[i] = ec._ProximaMarkets_proof(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var proximaOrderImplementors = []string{"ProximaOrder", "ProximaModel"}

func (ec *executionContext) _ProximaOrder(ctx context.Context, sel ast.SelectionSet, obj *models.ProximaOrder) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, proximaOrderImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProximaOrder")
		case "order":
			out.Values[i] = ec._ProximaOrder_order(ctx, field, obj)
		case "proof":
			out.Values[i] = ec._ProximaOrder_proof(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var proximaTimelocksImplementors = []string{"ProximaTimelocks", "ProximaModel"}

func (ec *executionContext) _ProximaTimelocks(ctx context.Context, sel ast.SelectionSet, obj *models.ProximaTimelocks) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, proximaTimelocksImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProximaTimelocks")
		case "timelocks":
			out.Values[i] = ec._ProximaTimelocks_timelocks(ctx, field, obj)
		case "proof":
			out.Values[i] = ec._ProximaTimelocks_proof(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var proximaTokensImplementors = []string{"ProximaTokens", "ProximaModel"}

func (ec *executionContext) _ProximaTokens(ctx context.Context, sel ast.SelectionSet, obj *models.ProximaTokens) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, proximaTokensImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProximaTokens")
		case "tokens":
			out.Values[i] = ec._ProximaTokens_tokens(ctx, field, obj)
		case "proof":
			out.Values[i] = ec._ProximaTokens_proof(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var proximaTradeImplementors = []string{"ProximaTrade"}

func (ec *executionContext) _ProximaTrade(ctx context.Context, sel ast.SelectionSet, obj *models.ProximaTrade) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, proximaTradeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProximaTrade")
		case "trade":
			out.Values[i] = ec._ProximaTrade_trade(ctx, field, obj)
		case "proof":
			out.Values[i] = ec._ProximaTrade_proof(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var proximaTransactionImplementors = []string{"ProximaTransaction", "ProximaModel"}

func (ec *executionContext) _ProximaTransaction(ctx context.Context, sel ast.SelectionSet, obj *models.ProximaTransaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, proximaTransactionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProximaTransaction")
		case "transaction":
			out.Values[i] = ec._ProximaTransaction_transaction(ctx, field, obj)
		case "proof":
			out.Values[i] = ec._ProximaTransaction_proof(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var proximaValidatorsImplementors = []string{"ProximaValidators", "ProximaModel"}

func (ec *executionContext) _ProximaValidators(ctx context.Context, sel ast.SelectionSet, obj *models.ProximaValidators) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, proximaValidatorsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProximaValidators")
		case "validators":
			out.Values[i] = ec._ProximaValidators_validators(ctx, field, obj)
		case "proof":
			out.Values[i] = ec._ProximaValidators_proof(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "blockStats":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_blockStats(ctx, field)
				return res
			})
		case "fees":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_fees(ctx, field)
				return res
			})
		case "tokens":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tokens(ctx, field)
				return res
			})
		case "account":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_account(ctx, field)
				return res
			})
		case "orders":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_orders(ctx, field)
				return res
			})
		case "order":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_order(ctx, field)
				return res
			})
		case "transactions":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_transactions(ctx, field)
				return res
			})
		case "transaction":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_transaction(ctx, field)
				return res
			})
		case "markets":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_markets(ctx, field)
				return res
			})
		case "marketTicker":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_marketTicker(ctx, field)
				return res
			})
		case "marketTickers":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_marketTickers(ctx, field)
				return res
			})
		case "marketDepth":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_marketDepth(ctx, field)
				return res
			})
		case "marketCandleSticks":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_marketCandleSticks(ctx, field)
				return res
			})
		case "trades":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_trades(ctx, field)
				return res
			})
		case "trade":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_trade(ctx, field)
				return res
			})
		case "atomicSwaps":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_atomicSwaps(ctx, field)
				return res
			})
		case "atomicSwap":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_atomicSwap(ctx, field)
				return res
			})
		case "validators":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_validators(ctx, field)
				return res
			})
		case "timelocks":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_timelocks(ctx, field)
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var timelockImplementors = []string{"Timelock"}

func (ec *executionContext) _Timelock(ctx context.Context, sel ast.SelectionSet, obj *models.Timelock) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, timelockImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Timelock")
		case "ID":
			out.Values[i] = ec._Timelock_ID(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Timelock_description(ctx, field, obj)
		case "amount":
			out.Values[i] = ec._Timelock_amount(ctx, field, obj)
		case "locktime":
			out.Values[i] = ec._Timelock_locktime(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var timelockListImplementors = []string{"TimelockList"}

func (ec *executionContext) _TimelockList(ctx context.Context, sel ast.SelectionSet, obj *models.TimelockList) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, timelockListImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TimelockList")
		case "timelocks":
			out.Values[i] = ec._TimelockList_timelocks(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tokenImplementors = []string{"Token"}

func (ec *executionContext) _Token(ctx context.Context, sel ast.SelectionSet, obj *models.Token) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, tokenImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Token")
		case "name":
			out.Values[i] = ec._Token_name(ctx, field, obj)
		case "symbol":
			out.Values[i] = ec._Token_symbol(ctx, field, obj)
		case "original_symbol":
			out.Values[i] = ec._Token_original_symbol(ctx, field, obj)
		case "total_supply":
			out.Values[i] = ec._Token_total_supply(ctx, field, obj)
		case "owner":
			out.Values[i] = ec._Token_owner(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tradeImplementors = []string{"Trade"}

func (ec *executionContext) _Trade(ctx context.Context, sel ast.SelectionSet, obj *models.Trade) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, tradeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Trade")
		case "baseAsset":
			out.Values[i] = ec._Trade_baseAsset(ctx, field, obj)
		case "blockHeight":
			out.Values[i] = ec._Trade_blockHeight(ctx, field, obj)
		case "buyFee":
			out.Values[i] = ec._Trade_buyFee(ctx, field, obj)
		case "buyerId":
			out.Values[i] = ec._Trade_buyerId(ctx, field, obj)
		case "buyerOrderId":
			out.Values[i] = ec._Trade_buyerOrderId(ctx, field, obj)
		case "buySingleFee":
			out.Values[i] = ec._Trade_buySingleFee(ctx, field, obj)
		case "price":
			out.Values[i] = ec._Trade_price(ctx, field, obj)
		case "quantity":
			out.Values[i] = ec._Trade_quantity(ctx, field, obj)
		case "quoteAsset":
			out.Values[i] = ec._Trade_quoteAsset(ctx, field, obj)
		case "sellFee":
			out.Values[i] = ec._Trade_sellFee(ctx, field, obj)
		case "sellerId":
			out.Values[i] = ec._Trade_sellerId(ctx, field, obj)
		case "sellerOrderId":
			out.Values[i] = ec._Trade_sellerOrderId(ctx, field, obj)
		case "sellSingleFee":
			out.Values[i] = ec._Trade_sellSingleFee(ctx, field, obj)
		case "symbol":
			out.Values[i] = ec._Trade_symbol(ctx, field, obj)
		case "tickType":
			out.Values[i] = ec._Trade_tickType(ctx, field, obj)
		case "time":
			out.Values[i] = ec._Trade_time(ctx, field, obj)
		case "tradeId":
			out.Values[i] = ec._Trade_tradeId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var transactionImplementors = []string{"Transaction"}

func (ec *executionContext) _Transaction(ctx context.Context, sel ast.SelectionSet, obj *models.Transaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, transactionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Transaction")
		case "blockHeight":
			out.Values[i] = ec._Transaction_blockHeight(ctx, field, obj)
		case "code":
			out.Values[i] = ec._Transaction_code(ctx, field, obj)
		case "data":
			out.Values[i] = ec._Transaction_data(ctx, field, obj)
		case "fromAddr":
			out.Values[i] = ec._Transaction_fromAddr(ctx, field, obj)
		case "memo":
			out.Values[i] = ec._Transaction_memo(ctx, field, obj)
		case "orderId":
			out.Values[i] = ec._Transaction_orderId(ctx, field, obj)
		case "proposalId":
			out.Values[i] = ec._Transaction_proposalId(ctx, field, obj)
		case "sequence":
			out.Values[i] = ec._Transaction_sequence(ctx, field, obj)
		case "source":
			out.Values[i] = ec._Transaction_source(ctx, field, obj)
		case "swapId":
			out.Values[i] = ec._Transaction_swapId(ctx, field, obj)
		case "timeStamp":
			out.Values[i] = ec._Transaction_timeStamp(ctx, field, obj)
		case "toAddr":
			out.Values[i] = ec._Transaction_toAddr(ctx, field, obj)
		case "txAsset":
			out.Values[i] = ec._Transaction_txAsset(ctx, field, obj)
		case "txFee":
			out.Values[i] = ec._Transaction_txFee(ctx, field, obj)
		case "txHash":
			out.Values[i] = ec._Transaction_txHash(ctx, field, obj)
		case "txType":
			out.Values[i] = ec._Transaction_txType(ctx, field, obj)
		case "value":
			out.Values[i] = ec._Transaction_value(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var validatorImplementors = []string{"Validator"}

func (ec *executionContext) _Validator(ctx context.Context, sel ast.SelectionSet, obj *models.Validator) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, validatorImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Validator")
		case "address":
			out.Values[i] = ec._Validator_address(ctx, field, obj)
		case "pub_key":
			out.Values[i] = ec._Validator_pub_key(ctx, field, obj)
		case "voting_power":
			out.Values[i] = ec._Validator_voting_power(ctx, field, obj)
		case "accum":
			out.Values[i] = ec._Validator_accum(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.RequestContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalOAccount2githubcomproximaonebinancechainsubgraphpkgmodelsAccount(ctx context.Context, sel ast.SelectionSet, v models.Account) graphql.Marshaler {
	return ec._Account(ctx, sel, &v)
}

func (ec *executionContext) marshalOAccount2githubcomproximaonebinancechainsubgraphpkgmodelsAccount(ctx context.Context, sel ast.SelectionSet, v *models.Account) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Account(ctx, sel, v)
}

func (ec *executionContext) marshalOAtomicSwap2githubcomproximaonebinancechainsubgraphpkgmodelsAtomicSwap(ctx context.Context, sel ast.SelectionSet, v models.AtomicSwap) graphql.Marshaler {
	return ec._AtomicSwap(ctx, sel, &v)
}

func (ec *executionContext) marshalOAtomicSwap2githubcomproximaonebinancechainsubgraphpkgmodelsAtomicSwap(ctx context.Context, sel ast.SelectionSet, v *models.AtomicSwap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AtomicSwap(ctx, sel, v)
}

func (ec *executionContext) marshalOBalance2githubcomproximaonebinancechainsubgraphpkgmodelsBalance(ctx context.Context, sel ast.SelectionSet, v models.Balance) graphql.Marshaler {
	return ec._Balance(ctx, sel, &v)
}

func (ec *executionContext) marshalOBalance2githubcomproximaonebinancechainsubgraphpkgmodelsBalance(ctx context.Context, sel ast.SelectionSet, v []*models.Balance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOBalance2githubcomproximaonebinancechainsubgraphpkgmodelsBalance(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOBalance2githubcomproximaonebinancechainsubgraphpkgmodelsBalance(ctx context.Context, sel ast.SelectionSet, v *models.Balance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Balance(ctx, sel, v)
}

func (ec *executionContext) marshalOBlockStats2githubcomproximaonebinancechainsubgraphpkgmodelsBlockStats(ctx context.Context, sel ast.SelectionSet, v models.BlockStats) graphql.Marshaler {
	return ec._BlockStats(ctx, sel, &v)
}

func (ec *executionContext) marshalOBlockStats2githubcomproximaonebinancechainsubgraphpkgmodelsBlockStats(ctx context.Context, sel ast.SelectionSet, v *models.BlockStats) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BlockStats(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBoolean2bool(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOBoolean2bool(ctx, sel, *v)
}

func (ec *executionContext) marshalOCandleStick2githubcomproximaonebinancechainsubgraphpkgmodelsCandleStick(ctx context.Context, sel ast.SelectionSet, v models.CandleStick) graphql.Marshaler {
	return ec._CandleStick(ctx, sel, &v)
}

func (ec *executionContext) marshalOCandleStick2githubcomproximaonebinancechainsubgraphpkgmodelsCandleStick(ctx context.Context, sel ast.SelectionSet, v []*models.CandleStick) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCandleStick2githubcomproximaonebinancechainsubgraphpkgmodelsCandleStick(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCandleStick2githubcomproximaonebinancechainsubgraphpkgmodelsCandleStick(ctx context.Context, sel ast.SelectionSet, v *models.CandleStick) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CandleStick(ctx, sel, v)
}

func (ec *executionContext) marshalOCoin2githubcomproximaonebinancechainsubgraphpkgmodelsCoin(ctx context.Context, sel ast.SelectionSet, v models.Coin) graphql.Marshaler {
	return ec._Coin(ctx, sel, &v)
}

func (ec *executionContext) marshalOCoin2githubcomproximaonebinancechainsubgraphpkgmodelsCoin(ctx context.Context, sel ast.SelectionSet, v *models.Coin) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Coin(ctx, sel, v)
}

func (ec *executionContext) marshalOFee2githubcomproximaonebinancechainsubgraphpkgmodelsFee(ctx context.Context, sel ast.SelectionSet, v models.Fee) graphql.Marshaler {
	return ec._Fee(ctx, sel, &v)
}

func (ec *executionContext) marshalOFee2githubcomproximaonebinancechainsubgraphpkgmodelsFee(ctx context.Context, sel ast.SelectionSet, v []*models.Fee) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOFee2githubcomproximaonebinancechainsubgraphpkgmodelsFee(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOFee2githubcomproximaonebinancechainsubgraphpkgmodelsFee(ctx context.Context, sel ast.SelectionSet, v *models.Fee) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Fee(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	return graphql.UnmarshalFloat(v)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	return graphql.MarshalFloat(v)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOFloat2float64(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOFloat2float64(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) ([]*int, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*int, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v []*int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOInt2int(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInt2int(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOInt2int(ctx, sel, *v)
}

func (ec *executionContext) marshalOMarket2githubcomproximaonebinancechainsubgraphpkgmodelsMarket(ctx context.Context, sel ast.SelectionSet, v models.Market) graphql.Marshaler {
	return ec._Market(ctx, sel, &v)
}

func (ec *executionContext) marshalOMarket2githubcomproximaonebinancechainsubgraphpkgmodelsMarket(ctx context.Context, sel ast.SelectionSet, v []*models.Market) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMarket2githubcomproximaonebinancechainsubgraphpkgmodelsMarket(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOMarket2githubcomproximaonebinancechainsubgraphpkgmodelsMarket(ctx context.Context, sel ast.SelectionSet, v *models.Market) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Market(ctx, sel, v)
}

func (ec *executionContext) marshalOMarketDepth2githubcomproximaonebinancechainsubgraphpkgmodelsMarketDepth(ctx context.Context, sel ast.SelectionSet, v models.MarketDepth) graphql.Marshaler {
	return ec._MarketDepth(ctx, sel, &v)
}

func (ec *executionContext) marshalOMarketDepth2githubcomproximaonebinancechainsubgraphpkgmodelsMarketDepth(ctx context.Context, sel ast.SelectionSet, v *models.MarketDepth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MarketDepth(ctx, sel, v)
}

func (ec *executionContext) marshalOMarketTicker2githubcomproximaonebinancechainsubgraphpkgmodelsMarketTicker(ctx context.Context, sel ast.SelectionSet, v models.MarketTicker) graphql.Marshaler {
	return ec._MarketTicker(ctx, sel, &v)
}

func (ec *executionContext) marshalOMarketTicker2githubcomproximaonebinancechainsubgraphpkgmodelsMarketTicker(ctx context.Context, sel ast.SelectionSet, v []*models.MarketTicker) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMarketTicker2githubcomproximaonebinancechainsubgraphpkgmodelsMarketTicker(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOMarketTicker2githubcomproximaonebinancechainsubgraphpkgmodelsMarketTicker(ctx context.Context, sel ast.SelectionSet, v *models.MarketTicker) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MarketTicker(ctx, sel, v)
}

func (ec *executionContext) marshalOOrder2githubcomproximaonebinancechainsubgraphpkgmodelsOrder(ctx context.Context, sel ast.SelectionSet, v models.Order) graphql.Marshaler {
	return ec._Order(ctx, sel, &v)
}

func (ec *executionContext) marshalOOrder2githubcomproximaonebinancechainsubgraphpkgmodelsOrder(ctx context.Context, sel ast.SelectionSet, v []*models.Order) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOOrder2githubcomproximaonebinancechainsubgraphpkgmodelsOrder(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOOrder2githubcomproximaonebinancechainsubgraphpkgmodelsOrder(ctx context.Context, sel ast.SelectionSet, v *models.Order) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Order(ctx, sel, v)
}

func (ec *executionContext) marshalOProof2githubcomproximaonebinancechainsubgraphpkgmodelsProof(ctx context.Context, sel ast.SelectionSet, v models.Proof) graphql.Marshaler {
	return ec._Proof(ctx, sel, &v)
}

func (ec *executionContext) marshalOProof2githubcomproximaonebinancechainsubgraphpkgmodelsProof(ctx context.Context, sel ast.SelectionSet, v *models.Proof) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Proof(ctx, sel, v)
}

func (ec *executionContext) marshalOProximaAccount2githubcomproximaonebinancechainsubgraphpkgmodelsProximaAccount(ctx context.Context, sel ast.SelectionSet, v models.ProximaAccount) graphql.Marshaler {
	return ec._ProximaAccount(ctx, sel, &v)
}

func (ec *executionContext) marshalOProximaAccount2githubcomproximaonebinancechainsubgraphpkgmodelsProximaAccount(ctx context.Context, sel ast.SelectionSet, v *models.ProximaAccount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProximaAccount(ctx, sel, v)
}

func (ec *executionContext) marshalOProximaAtomicSwap2githubcomproximaonebinancechainsubgraphpkgmodelsProximaAtomicSwap(ctx context.Context, sel ast.SelectionSet, v models.ProximaAtomicSwap) graphql.Marshaler {
	return ec._ProximaAtomicSwap(ctx, sel, &v)
}

func (ec *executionContext) marshalOProximaAtomicSwap2githubcomproximaonebinancechainsubgraphpkgmodelsProximaAtomicSwap(ctx context.Context, sel ast.SelectionSet, v []*models.ProximaAtomicSwap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOProximaAtomicSwap2githubcomproximaonebinancechainsubgraphpkgmodelsProximaAtomicSwap(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOProximaAtomicSwap2githubcomproximaonebinancechainsubgraphpkgmodelsProximaAtomicSwap(ctx context.Context, sel ast.SelectionSet, v *models.ProximaAtomicSwap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProximaAtomicSwap(ctx, sel, v)
}

func (ec *executionContext) marshalOProximaBlockStats2githubcomproximaonebinancechainsubgraphpkgmodelsProximaBlockStats(ctx context.Context, sel ast.SelectionSet, v models.ProximaBlockStats) graphql.Marshaler {
	return ec._ProximaBlockStats(ctx, sel, &v)
}

func (ec *executionContext) marshalOProximaBlockStats2githubcomproximaonebinancechainsubgraphpkgmodelsProximaBlockStats(ctx context.Context, sel ast.SelectionSet, v *models.ProximaBlockStats) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProximaBlockStats(ctx, sel, v)
}

func (ec *executionContext) marshalOProximaFees2githubcomproximaonebinancechainsubgraphpkgmodelsProximaFees(ctx context.Context, sel ast.SelectionSet, v models.ProximaFees) graphql.Marshaler {
	return ec._ProximaFees(ctx, sel, &v)
}

func (ec *executionContext) marshalOProximaFees2githubcomproximaonebinancechainsubgraphpkgmodelsProximaFees(ctx context.Context, sel ast.SelectionSet, v *models.ProximaFees) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProximaFees(ctx, sel, v)
}

func (ec *executionContext) marshalOProximaMarketCandleSticks2githubcomproximaonebinancechainsubgraphpkgmodelsProximaMarketCandleSticks(ctx context.Context, sel ast.SelectionSet, v models.ProximaMarketCandleSticks) graphql.Marshaler {
	return ec._ProximaMarketCandleSticks(ctx, sel, &v)
}

func (ec *executionContext) marshalOProximaMarketCandleSticks2githubcomproximaonebinancechainsubgraphpkgmodelsProximaMarketCandleSticks(ctx context.Context, sel ast.SelectionSet, v *models.ProximaMarketCandleSticks) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProximaMarketCandleSticks(ctx, sel, v)
}

func (ec *executionContext) marshalOProximaMarketDepth2githubcomproximaonebinancechainsubgraphpkgmodelsProximaMarketDepth(ctx context.Context, sel ast.SelectionSet, v models.ProximaMarketDepth) graphql.Marshaler {
	return ec._ProximaMarketDepth(ctx, sel, &v)
}

func (ec *executionContext) marshalOProximaMarketDepth2githubcomproximaonebinancechainsubgraphpkgmodelsProximaMarketDepth(ctx context.Context, sel ast.SelectionSet, v *models.ProximaMarketDepth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProximaMarketDepth(ctx, sel, v)
}

func (ec *executionContext) marshalOProximaMarketTicker2githubcomproximaonebinancechainsubgraphpkgmodelsProximaMarketTicker(ctx context.Context, sel ast.SelectionSet, v models.ProximaMarketTicker) graphql.Marshaler {
	return ec._ProximaMarketTicker(ctx, sel, &v)
}

func (ec *executionContext) marshalOProximaMarketTicker2githubcomproximaonebinancechainsubgraphpkgmodelsProximaMarketTicker(ctx context.Context, sel ast.SelectionSet, v *models.ProximaMarketTicker) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProximaMarketTicker(ctx, sel, v)
}

func (ec *executionContext) marshalOProximaMarketTickers2githubcomproximaonebinancechainsubgraphpkgmodelsProximaMarketTickers(ctx context.Context, sel ast.SelectionSet, v models.ProximaMarketTickers) graphql.Marshaler {
	return ec._ProximaMarketTickers(ctx, sel, &v)
}

func (ec *executionContext) marshalOProximaMarketTickers2githubcomproximaonebinancechainsubgraphpkgmodelsProximaMarketTickers(ctx context.Context, sel ast.SelectionSet, v *models.ProximaMarketTickers) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProximaMarketTickers(ctx, sel, v)
}

func (ec *executionContext) marshalOProximaMarkets2githubcomproximaonebinancechainsubgraphpkgmodelsProximaMarkets(ctx context.Context, sel ast.SelectionSet, v models.ProximaMarkets) graphql.Marshaler {
	return ec._ProximaMarkets(ctx, sel, &v)
}

func (ec *executionContext) marshalOProximaMarkets2githubcomproximaonebinancechainsubgraphpkgmodelsProximaMarkets(ctx context.Context, sel ast.SelectionSet, v *models.ProximaMarkets) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProximaMarkets(ctx, sel, v)
}

func (ec *executionContext) marshalOProximaOrder2githubcomproximaonebinancechainsubgraphpkgmodelsProximaOrder(ctx context.Context, sel ast.SelectionSet, v models.ProximaOrder) graphql.Marshaler {
	return ec._ProximaOrder(ctx, sel, &v)
}

func (ec *executionContext) marshalOProximaOrder2githubcomproximaonebinancechainsubgraphpkgmodelsProximaOrder(ctx context.Context, sel ast.SelectionSet, v []*models.ProximaOrder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOProximaOrder2githubcomproximaonebinancechainsubgraphpkgmodelsProximaOrder(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOProximaOrder2githubcomproximaonebinancechainsubgraphpkgmodelsProximaOrder(ctx context.Context, sel ast.SelectionSet, v *models.ProximaOrder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProximaOrder(ctx, sel, v)
}

func (ec *executionContext) marshalOProximaTimelocks2githubcomproximaonebinancechainsubgraphpkgmodelsProximaTimelocks(ctx context.Context, sel ast.SelectionSet, v models.ProximaTimelocks) graphql.Marshaler {
	return ec._ProximaTimelocks(ctx, sel, &v)
}

func (ec *executionContext) marshalOProximaTimelocks2githubcomproximaonebinancechainsubgraphpkgmodelsProximaTimelocks(ctx context.Context, sel ast.SelectionSet, v *models.ProximaTimelocks) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProximaTimelocks(ctx, sel, v)
}

func (ec *executionContext) marshalOProximaTokens2githubcomproximaonebinancechainsubgraphpkgmodelsProximaTokens(ctx context.Context, sel ast.SelectionSet, v models.ProximaTokens) graphql.Marshaler {
	return ec._ProximaTokens(ctx, sel, &v)
}

func (ec *executionContext) marshalOProximaTokens2githubcomproximaonebinancechainsubgraphpkgmodelsProximaTokens(ctx context.Context, sel ast.SelectionSet, v *models.ProximaTokens) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProximaTokens(ctx, sel, v)
}

func (ec *executionContext) marshalOProximaTrade2githubcomproximaonebinancechainsubgraphpkgmodelsProximaTrade(ctx context.Context, sel ast.SelectionSet, v models.ProximaTrade) graphql.Marshaler {
	return ec._ProximaTrade(ctx, sel, &v)
}

func (ec *executionContext) marshalOProximaTrade2githubcomproximaonebinancechainsubgraphpkgmodelsProximaTrade(ctx context.Context, sel ast.SelectionSet, v []*models.ProximaTrade) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOProximaTrade2githubcomproximaonebinancechainsubgraphpkgmodelsProximaTrade(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOProximaTrade2githubcomproximaonebinancechainsubgraphpkgmodelsProximaTrade(ctx context.Context, sel ast.SelectionSet, v *models.ProximaTrade) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProximaTrade(ctx, sel, v)
}

func (ec *executionContext) marshalOProximaTransaction2githubcomproximaonebinancechainsubgraphpkgmodelsProximaTransaction(ctx context.Context, sel ast.SelectionSet, v models.ProximaTransaction) graphql.Marshaler {
	return ec._ProximaTransaction(ctx, sel, &v)
}

func (ec *executionContext) marshalOProximaTransaction2githubcomproximaonebinancechainsubgraphpkgmodelsProximaTransaction(ctx context.Context, sel ast.SelectionSet, v []*models.ProximaTransaction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOProximaTransaction2githubcomproximaonebinancechainsubgraphpkgmodelsProximaTransaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOProximaTransaction2githubcomproximaonebinancechainsubgraphpkgmodelsProximaTransaction(ctx context.Context, sel ast.SelectionSet, v *models.ProximaTransaction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProximaTransaction(ctx, sel, v)
}

func (ec *executionContext) marshalOProximaValidators2githubcomproximaonebinancechainsubgraphpkgmodelsProximaValidators(ctx context.Context, sel ast.SelectionSet, v models.ProximaValidators) graphql.Marshaler {
	return ec._ProximaValidators(ctx, sel, &v)
}

func (ec *executionContext) marshalOProximaValidators2githubcomproximaonebinancechainsubgraphpkgmodelsProximaValidators(ctx context.Context, sel ast.SelectionSet, v *models.ProximaValidators) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProximaValidators(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]*string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalOString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2string(ctx, sel, *v)
}

func (ec *executionContext) marshalOTimelock2githubcomproximaonebinancechainsubgraphpkgmodelsTimelock(ctx context.Context, sel ast.SelectionSet, v models.Timelock) graphql.Marshaler {
	return ec._Timelock(ctx, sel, &v)
}

func (ec *executionContext) marshalOTimelock2githubcomproximaonebinancechainsubgraphpkgmodelsTimelock(ctx context.Context, sel ast.SelectionSet, v []*models.Timelock) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTimelock2githubcomproximaonebinancechainsubgraphpkgmodelsTimelock(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOTimelock2githubcomproximaonebinancechainsubgraphpkgmodelsTimelock(ctx context.Context, sel ast.SelectionSet, v *models.Timelock) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Timelock(ctx, sel, v)
}

func (ec *executionContext) marshalOTimelockList2githubcomproximaonebinancechainsubgraphpkgmodelsTimelockList(ctx context.Context, sel ast.SelectionSet, v models.TimelockList) graphql.Marshaler {
	return ec._TimelockList(ctx, sel, &v)
}

func (ec *executionContext) marshalOTimelockList2githubcomproximaonebinancechainsubgraphpkgmodelsTimelockList(ctx context.Context, sel ast.SelectionSet, v *models.TimelockList) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TimelockList(ctx, sel, v)
}

func (ec *executionContext) marshalOToken2githubcomproximaonebinancechainsubgraphpkgmodelsToken(ctx context.Context, sel ast.SelectionSet, v models.Token) graphql.Marshaler {
	return ec._Token(ctx, sel, &v)
}

func (ec *executionContext) marshalOToken2githubcomproximaonebinancechainsubgraphpkgmodelsToken(ctx context.Context, sel ast.SelectionSet, v []*models.Token) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOToken2githubcomproximaonebinancechainsubgraphpkgmodelsToken(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOToken2githubcomproximaonebinancechainsubgraphpkgmodelsToken(ctx context.Context, sel ast.SelectionSet, v *models.Token) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Token(ctx, sel, v)
}

func (ec *executionContext) marshalOTrade2githubcomproximaonebinancechainsubgraphpkgmodelsTrade(ctx context.Context, sel ast.SelectionSet, v models.Trade) graphql.Marshaler {
	return ec._Trade(ctx, sel, &v)
}

func (ec *executionContext) marshalOTrade2githubcomproximaonebinancechainsubgraphpkgmodelsTrade(ctx context.Context, sel ast.SelectionSet, v *models.Trade) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Trade(ctx, sel, v)
}

func (ec *executionContext) marshalOTransaction2githubcomproximaonebinancechainsubgraphpkgmodelsTransaction(ctx context.Context, sel ast.SelectionSet, v models.Transaction) graphql.Marshaler {
	return ec._Transaction(ctx, sel, &v)
}

func (ec *executionContext) marshalOTransaction2githubcomproximaonebinancechainsubgraphpkgmodelsTransaction(ctx context.Context, sel ast.SelectionSet, v *models.Transaction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Transaction(ctx, sel, v)
}

func (ec *executionContext) marshalOValidator2githubcomproximaonebinancechainsubgraphpkgmodelsValidator(ctx context.Context, sel ast.SelectionSet, v models.Validator) graphql.Marshaler {
	return ec._Validator(ctx, sel, &v)
}

func (ec *executionContext) marshalOValidator2githubcomproximaonebinancechainsubgraphpkgmodelsValidator(ctx context.Context, sel ast.SelectionSet, v []*models.Validator) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOValidator2githubcomproximaonebinancechainsubgraphpkgmodelsValidator(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOValidator2githubcomproximaonebinancechainsubgraphpkgmodelsValidator(ctx context.Context, sel ast.SelectionSet, v *models.Validator) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Validator(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v introspection.Schema) graphql.Marshaler {
	return ec.___Schema(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
